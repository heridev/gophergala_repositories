/*
  This code was generated by the Doc ORM Generator and isn't meant to be edited.
	If at all possible, please regenerate this file from your gp files instead of
	attempting to edit it to add changes.
*/

package store

import (
	"database/sql"
	"fmt"
	"log"
	"strconv"
	"strings"
)

type Conn struct {
	*sql.DB
	AppConfig
	reformat  bool
	returning bool
	Log       *log.Logger

	Account AccountScope

	Deck DeckScope

	Card CardScope
}

func Open(driverName, dataSourceName string) (*Conn, error) {
	c := &Conn{}
	if driverName == "postgres" {
		c.reformat = true
		c.returning = true
	}
	var err error
	c.DB, err = sql.Open(driverName, dataSourceName)
	if err != nil {
		return nil, err
	}
	c.AppConfig = NewAppConfig(driverName)

	c.Account = NewAccountScope(c)

	c.Deck = NewDeckScope(c)

	c.Card = NewCardScope(c)

	return c, nil
}

func (c *Conn) Clone() *Conn {
	c2 := &Conn{
		DB:        c.DB,
		AppConfig: c.AppConfig,
		reformat:  c.reformat,
		returning: c.returning,
		Log:       c.Log,
	}

	c2.Account = NewAccountScope(c2)

	c2.Deck = NewDeckScope(c2)

	c2.Card = NewCardScope(c2)

	return c2
}

type AccountScope struct {
	internalScope
}

func NewAccountScope(c *Conn) AccountScope {
	return AccountScope{
		internalScope{
			conn:          c,
			table:         c.SQLTable("Account"),
			currentColumn: c.SQLTable("Account") + "." + c.SQLColumn("Account", "ID"),
		},
	}
}

func (scope AccountScope) SetConn(conn *Conn) Scope {
	scope.conn = conn
	return scope
}

func (AccountScope) scopeName() string {
	return "Account"
}

// basic conditions
func (scope AccountScope) Eq(val interface{}) AccountScope {
	return AccountScope{scope.internalScope.Eq(val)}
}

func (scope AccountScope) Neq(val interface{}) AccountScope {
	return AccountScope{scope.internalScope.Neq(val)}
}

func (scope AccountScope) Gt(val interface{}) AccountScope {
	return AccountScope{scope.internalScope.Gt(val)}
}

func (scope AccountScope) Gte(val interface{}) AccountScope {
	return AccountScope{scope.internalScope.Gte(val)}
}

func (scope AccountScope) Lt(val interface{}) AccountScope {
	return AccountScope{scope.internalScope.Lt(val)}
}

func (scope AccountScope) Lte(val interface{}) AccountScope {
	return AccountScope{scope.internalScope.Lte(val)}
}

// multi value conditions
func (scope AccountScope) Between(lower, upper interface{}) AccountScope {
	return AccountScope{scope.internalScope.Between(lower, upper)}
}

func (scope AccountScope) In(vals ...interface{}) AccountScope {
	return AccountScope{scope.internalScope.In(vals...)}
}

func (scope AccountScope) NotIn(vals ...interface{}) AccountScope {
	return AccountScope{scope.internalScope.NotIn(vals...)}
}

func (scope AccountScope) Like(str string) AccountScope {
	return AccountScope{scope.internalScope.Like(str)}
}

func (scope AccountScope) Where(sql string, vals ...interface{}) AccountScope {
	return AccountScope{scope.internalScope.Where(sql, vals...)}
}

// ordering conditions
func (scope AccountScope) Order(ordering string) AccountScope {
	scope.order = append(scope.order, ordering)
	return scope
}

func (scope AccountScope) Desc() AccountScope {
	scope.order = append(scope.order, scope.currentColumn+" DESC")
	return scope
}

func (scope AccountScope) Asc() AccountScope {
	scope.order = append(scope.order, scope.currentColumn+" ASC")
	return scope
}

// Join funcs
func (scope AccountScope) OuterJoin(things ...Scope) AccountScope {
	return AccountScope{scope.internalScope.outerJoin("Account", things...)}
}

func (scope AccountScope) InnerJoin(things ...Scope) AccountScope {
	return AccountScope{scope.internalScope.innerJoin("Account", things...)}
}

// JoinBy allows you to specify the exact join SQL statment for one or more
// tables. You can also pass the Scope objects that you are manually joining,
// which are recorded for future Joining to work off of or to be Include'd.
func (scope AccountScope) JoinBy(joins string, joinedScopes ...Scope) AccountScope {
	scope.joins = append(scope.joins, joins)
	scope.joinedScopes = append(scope.joinedScopes, joinedScopes...)
	return scope
}

func (scope AccountScope) joinable() string {
	if scope.tableAlias != "" {
		return fmt.Sprintf(
			"%s AS %s",
			scope.conn.SQLTable("Account"),
			scope.tableAlias,
		)
	}
	return scope.conn.SQLTable("Account")
}

func (scope AccountScope) tableName() string {
	if scope.tableAlias != "" {
		return scope.tableAlias
	}
	return scope.conn.SQLTable("Account")
}

// aggregation filtering
func (scope AccountScope) Having(sql string, vals ...interface{}) AccountScope {
	scope.having = append(scope.having, sql)
	scope.haveVals = append(scope.haveVals, vals...)
	return scope
}

func (scope AccountScope) GroupBySQL(cols ...string) AccountScope {
	scope.groupBy = append(scope.groupBy, cols...)
	return scope
}

// Result count filtering
func (scope AccountScope) Limit(limit int64) AccountScope {
	scope.limit = &limit
	return scope
}

func (scope AccountScope) Offset(offset int64) AccountScope {
	scope.offset = &offset
	return scope
}

// misc scope operations
func (scope AccountScope) Clear() AccountScope {
	goods := []condition{}
	for _, cond := range scope.conditions {
		if !strings.HasSuffix(cond.column, "."+scope.currentColumn) {
			goods = append(goods, cond)
		}
	}
	scope.conditions = goods
	return scope
}

func (scope AccountScope) ClearAll() AccountScope {
	scope.conditions = []condition{}
	return scope
}

func (scope AccountScope) Base() AccountScope {
	return NewAccountScope(scope.conn)
}

// struct saving and loading
func (scope AccountScope) Find(id interface{}) (Account, error) {
	return scope.And(scope.Base().Eq(id)).Retrieve()
}

func (scope AccountScope) Retrieve() (Account, error) {
	val := &Account{}
	m := mapperForAccount(scope)
	m.Current = &val
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	row := scope.conn.QueryRow(ss, vv...)
	err := row.Scan(m.Scanners...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
	}
	val.cached_conn = scope.conn
	return *val, err

}

func (scope AccountScope) RetrieveAll() ([]Account, error) {
	m := mapperForAccount(scope)
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
		return []Account{}, err
	}
	defer rows.Close()

	vals := []Account{}

	for rows.Next() {
		temp := &Account{}
		m.Current = &temp
		err = rows.Scan(m.Scanners...)
		if err != nil {
			return []Account{}, err
		}
		temp.cached_conn = scope.conn
		vals = append(vals, *temp)
	}

	return vals, nil
}

func (scope AccountScope) SaveAll(vals []Account) error {
	for i := range vals {
		err := vals[i].Save(scope.conn)
		if err != nil {
			return err
		}
	}
	return nil
}

// Scope attribute updating
func (scope AccountScope) Set(val interface{}) AccountScope {
	if scope.updates == nil {
		scope.updates = make(map[string]interface{})
	}
	colName := strings.TrimPrefix(scope.currentColumn, scope.conn.SQLTable("Account")+".")
	scope.updates[colName] = val
	return scope
}

func (scope AccountScope) Update() error {
	sql, vals := scope.UpdateSQL()
	_, err := scope.conn.Exec(sql, vals...)
	return err
}

// subset plucking
func (scope AccountScope) Pick(sql string) AccountScope {
	scope.isDistinct = false
	scope.currentColumn = sql

	return scope
}

func (scope AccountScope) PluckStruct(result interface{}) error {
	return scope.internalScope.pluckStruct("Account", result)
}

// direct sql
func (scope AccountScope) Count() int64 {
	return scope.ID().Distinct().CountOf()
}

func (scope AccountScope) CountBy(sql string) int64 {
	scope.columns = []string{sql}
	ss, sv := scope.QuerySQL()
	var value int64
	row := scope.conn.QueryRow(ss, sv...)
	err := row.Scan(&value)
	if err != nil {
		panic(err)
	}

	return value
}

func (scope AccountScope) CountOf() int64 {
	if scope.isDistinct {
		return scope.CountBy(fmt.Sprintf("COUNT(DISTINCT %s)", scope.currentColumn))
	}
	return scope.CountBy(fmt.Sprintf("COUNT(%s)", scope.currentColumn))
}

func (scope AccountScope) UpdateBySQL(sql string, vals ...interface{}) error {
	scope.columns = []string{""}
	ss, sv := scope.query()
	ss = strings.TrimPrefix(ss, "SELECT FROM "+scope.table)
	ss = fmt.Sprintf("UPDATE %s SET %s %s", scope.table, sql, ss)
	_, err := scope.conn.Exec(ss, append(vals, sv...))
	return err
}

func (scope AccountScope) Delete() error {
	sql, cv := scope.DeleteSQL()
	if sql == "" {
		if err, ok := cv[0].(error); ok {
			return err
		} else {
			return fmt.Errorf("Unspecified Error in DeleteSQL()")
		}
	}
	_, err := scope.conn.Exec(sql, cv...)
	if err != nil {
		return fmt.Errorf("Encountered error: %v\nSQL: %s %v", err, sql, cv)
	}
	return nil
}
func (scope AccountScope) condSQL() (string, []interface{}) {
	conds := []string{}
	vals := []interface{}{}
	for _, condition := range scope.conditions {
		conds = append(conds, condition.ToSQL())
		vals = append(vals, condition.vals...)
	}
	return strings.Join(conds, " AND "), vals
}

// special
func (scope AccountScope) Clone() AccountScope {
	return scope
}

func (scope AccountScope) QuerySQL() (string, []interface{}) {
	return scope.query()
}

func (scope AccountScope) UpdateSQL() (string, []interface{}) {
	sql := fmt.Sprintf(
		"UPDATE %s SET ",
		scope.conn.SQLTable("Account"),
	)

	updates := []string{}
	vals := []interface{}{}
	for col, val := range scope.updates {
		updates = append(updates, col+" = ?")
		vals = append(vals, val)
	}
	sql += strings.Join(updates, ", ")

	if len(scope.conditions) > 0 {
		cs, cv := scope.conditionSQL()
		sql += " WHERE " + cs
		vals = append(vals, cv...)
	}
	return sql, vals
}

func (scope AccountScope) DeleteSQL() (string, []interface{}) {
	delScope := scope.Clone()
	if len(scope.joins) > 0 || len(scope.having) > 0 {
		ids, err := scope.ID().Distinct().PluckInt()
		if err != nil {
			return "", []interface{}{err}
		}
		delScope = delScope.ClearAll().ID().In(ids)
	}
	cs, cv := scope.condSQL()

	if cs == "" {
		sql := fmt.Sprintf("DELETE FROM %s", scope.table, cs)
		return sql, []interface{}{}
	} else {
		sql := fmt.Sprintf("DELETE FROM %s WHERE %s", scope.table, cs)
		return sql, cv
	}
}

// As sets a column alias
func (scope AccountScope) As(alias string) AccountScope {
	scope.currentAlias = alias
	return scope
}

// Alias sets a table alias
func (scope AccountScope) Alias(alias string) AccountScope {
	scope.tableAlias = alias
	return scope
}

func (scope AccountScope) Distinct() AccountScope {
	scope.isDistinct = true
	return scope
}

func (scope AccountScope) And(scopes ...Scope) AccountScope {
	for _, is := range scopes {
		scope.conditions = append(scope.conditions, is.conds()...)
	}
	return scope
}

func (scope AccountScope) Or(scopes ...Scope) AccountScope {
	c := condition{}
	ors := []string{}
	for _, oscope := range scopes {
		cond := []string{}
		conds := oscope.conds()
		if len(conds) == 1 {
			c.vals = append(c.vals, conds[0].vals...)
			ors = append(ors, conds[0].ToSQL())
		} else {
			for _, ocond := range conds {
				c.vals = append(c.vals, ocond.vals...)
				cond = append(cond, ocond.ToSQL())
			}
			ors = append(ors, "("+strings.Join(cond, " AND ")+")")
		}
	}
	c.cond = "(" + strings.Join(ors, " OR ") + ")"

	scope.conditions = append(scope.conditions, c)

	return scope
}

func (scope AccountScope) ID() AccountScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "ID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperAccountToID struct {
	Mapper *mapperAccount
}

func (m mapperAccountToID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).ID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope AccountScope) Email() AccountScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "Email")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperAccountToEmail struct {
	Mapper *mapperAccount
}

func (m mapperAccountToEmail) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Email = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Email = string(s)

	}

	return nil

}

func (scope AccountScope) Management() AccountScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "Management")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperAccountToManagement struct {
	Mapper *mapperAccount
}

func (m mapperAccountToManagement) Scan(v interface{}) error {

	if v == nil {
		// it is false or null, the zero values
	} else if b, ok := v.(bool); ok {

		(*m.Mapper.Current).Management = b

	} else if i, ok := v.(int64); ok {

		if i != 0 {
			(*m.Mapper.Current).Management = true
		}

	}

	return nil

}

func (scope AccountScope) CryptPassword() AccountScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "CryptPassword")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperAccountToCryptPassword struct {
	Mapper *mapperAccount
}

func (m mapperAccountToCryptPassword) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).CryptPassword = s

	}

	return nil

}

type mapperAccount struct {
	Current  **Account
	Columns  []string
	Scanners []interface{}
}

func mapperForAccount(scope AccountScope) *mapperAccount {
	m := &mapperAccount{}
	m.Columns = []string{scope.tableName() + "." + scope.conn.SQLColumn("Account", "ID"), scope.tableName() + "." + scope.conn.SQLColumn("Account", "Email"), scope.tableName() + "." + scope.conn.SQLColumn("Account", "Management"), scope.tableName() + "." + scope.conn.SQLColumn("Account", "CryptPassword")}
	m.Scanners = []interface{}{

		mapperAccountToID{m},

		mapperAccountToEmail{m},

		mapperAccountToManagement{m},

		mapperAccountToCryptPassword{m},
	}

	return m
}

type DeckScope struct {
	internalScope
}

func NewDeckScope(c *Conn) DeckScope {
	return DeckScope{
		internalScope{
			conn:          c,
			table:         c.SQLTable("Deck"),
			currentColumn: c.SQLTable("Deck") + "." + c.SQLColumn("Deck", "ID"),
		},
	}
}

func (scope DeckScope) SetConn(conn *Conn) Scope {
	scope.conn = conn
	return scope
}

func (DeckScope) scopeName() string {
	return "Deck"
}

// basic conditions
func (scope DeckScope) Eq(val interface{}) DeckScope {
	return DeckScope{scope.internalScope.Eq(val)}
}

func (scope DeckScope) Neq(val interface{}) DeckScope {
	return DeckScope{scope.internalScope.Neq(val)}
}

func (scope DeckScope) Gt(val interface{}) DeckScope {
	return DeckScope{scope.internalScope.Gt(val)}
}

func (scope DeckScope) Gte(val interface{}) DeckScope {
	return DeckScope{scope.internalScope.Gte(val)}
}

func (scope DeckScope) Lt(val interface{}) DeckScope {
	return DeckScope{scope.internalScope.Lt(val)}
}

func (scope DeckScope) Lte(val interface{}) DeckScope {
	return DeckScope{scope.internalScope.Lte(val)}
}

// multi value conditions
func (scope DeckScope) Between(lower, upper interface{}) DeckScope {
	return DeckScope{scope.internalScope.Between(lower, upper)}
}

func (scope DeckScope) In(vals ...interface{}) DeckScope {
	return DeckScope{scope.internalScope.In(vals...)}
}

func (scope DeckScope) NotIn(vals ...interface{}) DeckScope {
	return DeckScope{scope.internalScope.NotIn(vals...)}
}

func (scope DeckScope) Like(str string) DeckScope {
	return DeckScope{scope.internalScope.Like(str)}
}

func (scope DeckScope) Where(sql string, vals ...interface{}) DeckScope {
	return DeckScope{scope.internalScope.Where(sql, vals...)}
}

// ordering conditions
func (scope DeckScope) Order(ordering string) DeckScope {
	scope.order = append(scope.order, ordering)
	return scope
}

func (scope DeckScope) Desc() DeckScope {
	scope.order = append(scope.order, scope.currentColumn+" DESC")
	return scope
}

func (scope DeckScope) Asc() DeckScope {
	scope.order = append(scope.order, scope.currentColumn+" ASC")
	return scope
}

// Join funcs
func (scope DeckScope) OuterJoin(things ...Scope) DeckScope {
	return DeckScope{scope.internalScope.outerJoin("Deck", things...)}
}

func (scope DeckScope) InnerJoin(things ...Scope) DeckScope {
	return DeckScope{scope.internalScope.innerJoin("Deck", things...)}
}

// JoinBy allows you to specify the exact join SQL statment for one or more
// tables. You can also pass the Scope objects that you are manually joining,
// which are recorded for future Joining to work off of or to be Include'd.
func (scope DeckScope) JoinBy(joins string, joinedScopes ...Scope) DeckScope {
	scope.joins = append(scope.joins, joins)
	scope.joinedScopes = append(scope.joinedScopes, joinedScopes...)
	return scope
}

func (scope DeckScope) joinable() string {
	if scope.tableAlias != "" {
		return fmt.Sprintf(
			"%s AS %s",
			scope.conn.SQLTable("Deck"),
			scope.tableAlias,
		)
	}
	return scope.conn.SQLTable("Deck")
}

func (scope DeckScope) tableName() string {
	if scope.tableAlias != "" {
		return scope.tableAlias
	}
	return scope.conn.SQLTable("Deck")
}

// aggregation filtering
func (scope DeckScope) Having(sql string, vals ...interface{}) DeckScope {
	scope.having = append(scope.having, sql)
	scope.haveVals = append(scope.haveVals, vals...)
	return scope
}

func (scope DeckScope) GroupBySQL(cols ...string) DeckScope {
	scope.groupBy = append(scope.groupBy, cols...)
	return scope
}

// Result count filtering
func (scope DeckScope) Limit(limit int64) DeckScope {
	scope.limit = &limit
	return scope
}

func (scope DeckScope) Offset(offset int64) DeckScope {
	scope.offset = &offset
	return scope
}

// misc scope operations
func (scope DeckScope) Clear() DeckScope {
	goods := []condition{}
	for _, cond := range scope.conditions {
		if !strings.HasSuffix(cond.column, "."+scope.currentColumn) {
			goods = append(goods, cond)
		}
	}
	scope.conditions = goods
	return scope
}

func (scope DeckScope) ClearAll() DeckScope {
	scope.conditions = []condition{}
	return scope
}

func (scope DeckScope) Base() DeckScope {
	return NewDeckScope(scope.conn)
}

// struct saving and loading
func (scope DeckScope) Find(id interface{}) (Deck, error) {
	return scope.And(scope.Base().Eq(id)).Retrieve()
}

func (scope DeckScope) Retrieve() (Deck, error) {
	val := &Deck{}
	m := mapperForDeck(scope)
	m.Current = &val
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	row := scope.conn.QueryRow(ss, vv...)
	err := row.Scan(m.Scanners...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
	}
	val.cached_conn = scope.conn
	return *val, err

}

func (scope DeckScope) RetrieveAll() ([]Deck, error) {
	m := mapperForDeck(scope)
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
		return []Deck{}, err
	}
	defer rows.Close()

	vals := []Deck{}

	for rows.Next() {
		temp := &Deck{}
		m.Current = &temp
		err = rows.Scan(m.Scanners...)
		if err != nil {
			return []Deck{}, err
		}
		temp.cached_conn = scope.conn
		vals = append(vals, *temp)
	}

	return vals, nil
}

func (scope DeckScope) SaveAll(vals []Deck) error {
	for i := range vals {
		err := vals[i].Save(scope.conn)
		if err != nil {
			return err
		}
	}
	return nil
}

// Scope attribute updating
func (scope DeckScope) Set(val interface{}) DeckScope {
	if scope.updates == nil {
		scope.updates = make(map[string]interface{})
	}
	colName := strings.TrimPrefix(scope.currentColumn, scope.conn.SQLTable("Deck")+".")
	scope.updates[colName] = val
	return scope
}

func (scope DeckScope) Update() error {
	sql, vals := scope.UpdateSQL()
	_, err := scope.conn.Exec(sql, vals...)
	return err
}

// subset plucking
func (scope DeckScope) Pick(sql string) DeckScope {
	scope.isDistinct = false
	scope.currentColumn = sql

	return scope
}

func (scope DeckScope) PluckStruct(result interface{}) error {
	return scope.internalScope.pluckStruct("Deck", result)
}

// direct sql
func (scope DeckScope) Count() int64 {
	return scope.ID().Distinct().CountOf()
}

func (scope DeckScope) CountBy(sql string) int64 {
	scope.columns = []string{sql}
	ss, sv := scope.QuerySQL()
	var value int64
	row := scope.conn.QueryRow(ss, sv...)
	err := row.Scan(&value)
	if err != nil {
		panic(err)
	}

	return value
}

func (scope DeckScope) CountOf() int64 {
	if scope.isDistinct {
		return scope.CountBy(fmt.Sprintf("COUNT(DISTINCT %s)", scope.currentColumn))
	}
	return scope.CountBy(fmt.Sprintf("COUNT(%s)", scope.currentColumn))
}

func (scope DeckScope) UpdateBySQL(sql string, vals ...interface{}) error {
	scope.columns = []string{""}
	ss, sv := scope.query()
	ss = strings.TrimPrefix(ss, "SELECT FROM "+scope.table)
	ss = fmt.Sprintf("UPDATE %s SET %s %s", scope.table, sql, ss)
	_, err := scope.conn.Exec(ss, append(vals, sv...))
	return err
}

func (scope DeckScope) Delete() error {
	sql, cv := scope.DeleteSQL()
	if sql == "" {
		if err, ok := cv[0].(error); ok {
			return err
		} else {
			return fmt.Errorf("Unspecified Error in DeleteSQL()")
		}
	}
	_, err := scope.conn.Exec(sql, cv...)
	if err != nil {
		return fmt.Errorf("Encountered error: %v\nSQL: %s %v", err, sql, cv)
	}
	return nil
}
func (scope DeckScope) condSQL() (string, []interface{}) {
	conds := []string{}
	vals := []interface{}{}
	for _, condition := range scope.conditions {
		conds = append(conds, condition.ToSQL())
		vals = append(vals, condition.vals...)
	}
	return strings.Join(conds, " AND "), vals
}

// special
func (scope DeckScope) Clone() DeckScope {
	return scope
}

func (scope DeckScope) QuerySQL() (string, []interface{}) {
	return scope.query()
}

func (scope DeckScope) UpdateSQL() (string, []interface{}) {
	sql := fmt.Sprintf(
		"UPDATE %s SET ",
		scope.conn.SQLTable("Deck"),
	)

	updates := []string{}
	vals := []interface{}{}
	for col, val := range scope.updates {
		updates = append(updates, col+" = ?")
		vals = append(vals, val)
	}
	sql += strings.Join(updates, ", ")

	if len(scope.conditions) > 0 {
		cs, cv := scope.conditionSQL()
		sql += " WHERE " + cs
		vals = append(vals, cv...)
	}
	return sql, vals
}

func (scope DeckScope) DeleteSQL() (string, []interface{}) {
	delScope := scope.Clone()
	if len(scope.joins) > 0 || len(scope.having) > 0 {
		ids, err := scope.ID().Distinct().PluckInt()
		if err != nil {
			return "", []interface{}{err}
		}
		delScope = delScope.ClearAll().ID().In(ids)
	}
	cs, cv := scope.condSQL()

	if cs == "" {
		sql := fmt.Sprintf("DELETE FROM %s", scope.table, cs)
		return sql, []interface{}{}
	} else {
		sql := fmt.Sprintf("DELETE FROM %s WHERE %s", scope.table, cs)
		return sql, cv
	}
}

// As sets a column alias
func (scope DeckScope) As(alias string) DeckScope {
	scope.currentAlias = alias
	return scope
}

// Alias sets a table alias
func (scope DeckScope) Alias(alias string) DeckScope {
	scope.tableAlias = alias
	return scope
}

func (scope DeckScope) Distinct() DeckScope {
	scope.isDistinct = true
	return scope
}

func (scope DeckScope) And(scopes ...Scope) DeckScope {
	for _, is := range scopes {
		scope.conditions = append(scope.conditions, is.conds()...)
	}
	return scope
}

func (scope DeckScope) Or(scopes ...Scope) DeckScope {
	c := condition{}
	ors := []string{}
	for _, oscope := range scopes {
		cond := []string{}
		conds := oscope.conds()
		if len(conds) == 1 {
			c.vals = append(c.vals, conds[0].vals...)
			ors = append(ors, conds[0].ToSQL())
		} else {
			for _, ocond := range conds {
				c.vals = append(c.vals, ocond.vals...)
				cond = append(cond, ocond.ToSQL())
			}
			ors = append(ors, "("+strings.Join(cond, " AND ")+")")
		}
	}
	c.cond = "(" + strings.Join(ors, " OR ") + ")"

	scope.conditions = append(scope.conditions, c)

	return scope
}

func (scope DeckScope) ID() DeckScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "ID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperDeckToID struct {
	Mapper *mapperDeck
}

func (m mapperDeckToID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).ID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope DeckScope) Name() DeckScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "Name")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperDeckToName struct {
	Mapper *mapperDeck
}

func (m mapperDeckToName) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Name = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Name = string(s)

	}

	return nil

}

func (scope DeckScope) Description() DeckScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "Description")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperDeckToDescription struct {
	Mapper *mapperDeck
}

func (m mapperDeckToDescription) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Description = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Description = string(s)

	}

	return nil

}

func (scope DeckScope) Private() DeckScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "Private")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperDeckToPrivate struct {
	Mapper *mapperDeck
}

func (m mapperDeckToPrivate) Scan(v interface{}) error {

	if v == nil {
		// it is false or null, the zero values
	} else if b, ok := v.(bool); ok {

		(*m.Mapper.Current).Private = b

	} else if i, ok := v.(int64); ok {

		if i != 0 {
			(*m.Mapper.Current).Private = true
		}

	}

	return nil

}

func (scope DeckScope) FullGame() DeckScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "FullGame")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperDeckToFullGame struct {
	Mapper *mapperDeck
}

func (m mapperDeckToFullGame) Scan(v interface{}) error {

	if v == nil {
		// it is false or null, the zero values
	} else if b, ok := v.(bool); ok {

		(*m.Mapper.Current).FullGame = b

	} else if i, ok := v.(int64); ok {

		if i != 0 {
			(*m.Mapper.Current).FullGame = true
		}

	}

	return nil

}

func (scope DeckScope) GameType() DeckScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "GameType")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperDeckToGameType struct {
	Mapper *mapperDeck
}

func (m mapperDeckToGameType) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).GameType = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).GameType = string(s)

	}

	return nil

}

func (scope DeckScope) MinPlayer() DeckScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "MinPlayer")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperDeckToMinPlayer struct {
	Mapper *mapperDeck
}

func (m mapperDeckToMinPlayer) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).MinPlayer = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).MinPlayer = i

		return err
	}
	return nil

}

func (scope DeckScope) AccountID() DeckScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "AccountID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperDeckToAccountID struct {
	Mapper *mapperDeck
}

func (m mapperDeckToAccountID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).AccountID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).AccountID = i

		return err
	}
	return nil

}

type mapperDeck struct {
	Current  **Deck
	Columns  []string
	Scanners []interface{}
}

func mapperForDeck(scope DeckScope) *mapperDeck {
	m := &mapperDeck{}
	m.Columns = []string{scope.tableName() + "." + scope.conn.SQLColumn("Deck", "ID"), scope.tableName() + "." + scope.conn.SQLColumn("Deck", "Name"), scope.tableName() + "." + scope.conn.SQLColumn("Deck", "Description"), scope.tableName() + "." + scope.conn.SQLColumn("Deck", "Private"), scope.tableName() + "." + scope.conn.SQLColumn("Deck", "FullGame"), scope.tableName() + "." + scope.conn.SQLColumn("Deck", "GameType"), scope.tableName() + "." + scope.conn.SQLColumn("Deck", "MinPlayer"), scope.tableName() + "." + scope.conn.SQLColumn("Deck", "AccountID")}
	m.Scanners = []interface{}{

		mapperDeckToID{m},

		mapperDeckToName{m},

		mapperDeckToDescription{m},

		mapperDeckToPrivate{m},

		mapperDeckToFullGame{m},

		mapperDeckToGameType{m},

		mapperDeckToMinPlayer{m},

		mapperDeckToAccountID{m},
	}

	return m
}

type CardScope struct {
	internalScope
}

func NewCardScope(c *Conn) CardScope {
	return CardScope{
		internalScope{
			conn:          c,
			table:         c.SQLTable("Card"),
			currentColumn: c.SQLTable("Card") + "." + c.SQLColumn("Card", "ID"),
		},
	}
}

func (scope CardScope) SetConn(conn *Conn) Scope {
	scope.conn = conn
	return scope
}

func (CardScope) scopeName() string {
	return "Card"
}

// basic conditions
func (scope CardScope) Eq(val interface{}) CardScope {
	return CardScope{scope.internalScope.Eq(val)}
}

func (scope CardScope) Neq(val interface{}) CardScope {
	return CardScope{scope.internalScope.Neq(val)}
}

func (scope CardScope) Gt(val interface{}) CardScope {
	return CardScope{scope.internalScope.Gt(val)}
}

func (scope CardScope) Gte(val interface{}) CardScope {
	return CardScope{scope.internalScope.Gte(val)}
}

func (scope CardScope) Lt(val interface{}) CardScope {
	return CardScope{scope.internalScope.Lt(val)}
}

func (scope CardScope) Lte(val interface{}) CardScope {
	return CardScope{scope.internalScope.Lte(val)}
}

// multi value conditions
func (scope CardScope) Between(lower, upper interface{}) CardScope {
	return CardScope{scope.internalScope.Between(lower, upper)}
}

func (scope CardScope) In(vals ...interface{}) CardScope {
	return CardScope{scope.internalScope.In(vals...)}
}

func (scope CardScope) NotIn(vals ...interface{}) CardScope {
	return CardScope{scope.internalScope.NotIn(vals...)}
}

func (scope CardScope) Like(str string) CardScope {
	return CardScope{scope.internalScope.Like(str)}
}

func (scope CardScope) Where(sql string, vals ...interface{}) CardScope {
	return CardScope{scope.internalScope.Where(sql, vals...)}
}

// ordering conditions
func (scope CardScope) Order(ordering string) CardScope {
	scope.order = append(scope.order, ordering)
	return scope
}

func (scope CardScope) Desc() CardScope {
	scope.order = append(scope.order, scope.currentColumn+" DESC")
	return scope
}

func (scope CardScope) Asc() CardScope {
	scope.order = append(scope.order, scope.currentColumn+" ASC")
	return scope
}

// Join funcs
func (scope CardScope) OuterJoin(things ...Scope) CardScope {
	return CardScope{scope.internalScope.outerJoin("Card", things...)}
}

func (scope CardScope) InnerJoin(things ...Scope) CardScope {
	return CardScope{scope.internalScope.innerJoin("Card", things...)}
}

// JoinBy allows you to specify the exact join SQL statment for one or more
// tables. You can also pass the Scope objects that you are manually joining,
// which are recorded for future Joining to work off of or to be Include'd.
func (scope CardScope) JoinBy(joins string, joinedScopes ...Scope) CardScope {
	scope.joins = append(scope.joins, joins)
	scope.joinedScopes = append(scope.joinedScopes, joinedScopes...)
	return scope
}

func (scope CardScope) joinable() string {
	if scope.tableAlias != "" {
		return fmt.Sprintf(
			"%s AS %s",
			scope.conn.SQLTable("Card"),
			scope.tableAlias,
		)
	}
	return scope.conn.SQLTable("Card")
}

func (scope CardScope) tableName() string {
	if scope.tableAlias != "" {
		return scope.tableAlias
	}
	return scope.conn.SQLTable("Card")
}

// aggregation filtering
func (scope CardScope) Having(sql string, vals ...interface{}) CardScope {
	scope.having = append(scope.having, sql)
	scope.haveVals = append(scope.haveVals, vals...)
	return scope
}

func (scope CardScope) GroupBySQL(cols ...string) CardScope {
	scope.groupBy = append(scope.groupBy, cols...)
	return scope
}

// Result count filtering
func (scope CardScope) Limit(limit int64) CardScope {
	scope.limit = &limit
	return scope
}

func (scope CardScope) Offset(offset int64) CardScope {
	scope.offset = &offset
	return scope
}

// misc scope operations
func (scope CardScope) Clear() CardScope {
	goods := []condition{}
	for _, cond := range scope.conditions {
		if !strings.HasSuffix(cond.column, "."+scope.currentColumn) {
			goods = append(goods, cond)
		}
	}
	scope.conditions = goods
	return scope
}

func (scope CardScope) ClearAll() CardScope {
	scope.conditions = []condition{}
	return scope
}

func (scope CardScope) Base() CardScope {
	return NewCardScope(scope.conn)
}

// struct saving and loading
func (scope CardScope) Find(id interface{}) (Card, error) {
	return scope.And(scope.Base().Eq(id)).Retrieve()
}

func (scope CardScope) Retrieve() (Card, error) {
	val := &Card{}
	m := mapperForCard(scope)
	m.Current = &val
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	row := scope.conn.QueryRow(ss, vv...)
	err := row.Scan(m.Scanners...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
	}
	val.cached_conn = scope.conn
	return *val, err

}

func (scope CardScope) RetrieveAll() ([]Card, error) {
	m := mapperForCard(scope)
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
		return []Card{}, err
	}
	defer rows.Close()

	vals := []Card{}

	for rows.Next() {
		temp := &Card{}
		m.Current = &temp
		err = rows.Scan(m.Scanners...)
		if err != nil {
			return []Card{}, err
		}
		temp.cached_conn = scope.conn
		vals = append(vals, *temp)
	}

	return vals, nil
}

func (scope CardScope) SaveAll(vals []Card) error {
	for i := range vals {
		err := vals[i].Save(scope.conn)
		if err != nil {
			return err
		}
	}
	return nil
}

// Scope attribute updating
func (scope CardScope) Set(val interface{}) CardScope {
	if scope.updates == nil {
		scope.updates = make(map[string]interface{})
	}
	colName := strings.TrimPrefix(scope.currentColumn, scope.conn.SQLTable("Card")+".")
	scope.updates[colName] = val
	return scope
}

func (scope CardScope) Update() error {
	sql, vals := scope.UpdateSQL()
	_, err := scope.conn.Exec(sql, vals...)
	return err
}

// subset plucking
func (scope CardScope) Pick(sql string) CardScope {
	scope.isDistinct = false
	scope.currentColumn = sql

	return scope
}

func (scope CardScope) PluckStruct(result interface{}) error {
	return scope.internalScope.pluckStruct("Card", result)
}

// direct sql
func (scope CardScope) Count() int64 {
	return scope.ID().Distinct().CountOf()
}

func (scope CardScope) CountBy(sql string) int64 {
	scope.columns = []string{sql}
	ss, sv := scope.QuerySQL()
	var value int64
	row := scope.conn.QueryRow(ss, sv...)
	err := row.Scan(&value)
	if err != nil {
		panic(err)
	}

	return value
}

func (scope CardScope) CountOf() int64 {
	if scope.isDistinct {
		return scope.CountBy(fmt.Sprintf("COUNT(DISTINCT %s)", scope.currentColumn))
	}
	return scope.CountBy(fmt.Sprintf("COUNT(%s)", scope.currentColumn))
}

func (scope CardScope) UpdateBySQL(sql string, vals ...interface{}) error {
	scope.columns = []string{""}
	ss, sv := scope.query()
	ss = strings.TrimPrefix(ss, "SELECT FROM "+scope.table)
	ss = fmt.Sprintf("UPDATE %s SET %s %s", scope.table, sql, ss)
	_, err := scope.conn.Exec(ss, append(vals, sv...))
	return err
}

func (scope CardScope) Delete() error {
	sql, cv := scope.DeleteSQL()
	if sql == "" {
		if err, ok := cv[0].(error); ok {
			return err
		} else {
			return fmt.Errorf("Unspecified Error in DeleteSQL()")
		}
	}
	_, err := scope.conn.Exec(sql, cv...)
	if err != nil {
		return fmt.Errorf("Encountered error: %v\nSQL: %s %v", err, sql, cv)
	}
	return nil
}
func (scope CardScope) condSQL() (string, []interface{}) {
	conds := []string{}
	vals := []interface{}{}
	for _, condition := range scope.conditions {
		conds = append(conds, condition.ToSQL())
		vals = append(vals, condition.vals...)
	}
	return strings.Join(conds, " AND "), vals
}

// special
func (scope CardScope) Clone() CardScope {
	return scope
}

func (scope CardScope) QuerySQL() (string, []interface{}) {
	return scope.query()
}

func (scope CardScope) UpdateSQL() (string, []interface{}) {
	sql := fmt.Sprintf(
		"UPDATE %s SET ",
		scope.conn.SQLTable("Card"),
	)

	updates := []string{}
	vals := []interface{}{}
	for col, val := range scope.updates {
		updates = append(updates, col+" = ?")
		vals = append(vals, val)
	}
	sql += strings.Join(updates, ", ")

	if len(scope.conditions) > 0 {
		cs, cv := scope.conditionSQL()
		sql += " WHERE " + cs
		vals = append(vals, cv...)
	}
	return sql, vals
}

func (scope CardScope) DeleteSQL() (string, []interface{}) {
	delScope := scope.Clone()
	if len(scope.joins) > 0 || len(scope.having) > 0 {
		ids, err := scope.ID().Distinct().PluckInt()
		if err != nil {
			return "", []interface{}{err}
		}
		delScope = delScope.ClearAll().ID().In(ids)
	}
	cs, cv := scope.condSQL()

	if cs == "" {
		sql := fmt.Sprintf("DELETE FROM %s", scope.table, cs)
		return sql, []interface{}{}
	} else {
		sql := fmt.Sprintf("DELETE FROM %s WHERE %s", scope.table, cs)
		return sql, cv
	}
}

// As sets a column alias
func (scope CardScope) As(alias string) CardScope {
	scope.currentAlias = alias
	return scope
}

// Alias sets a table alias
func (scope CardScope) Alias(alias string) CardScope {
	scope.tableAlias = alias
	return scope
}

func (scope CardScope) Distinct() CardScope {
	scope.isDistinct = true
	return scope
}

func (scope CardScope) And(scopes ...Scope) CardScope {
	for _, is := range scopes {
		scope.conditions = append(scope.conditions, is.conds()...)
	}
	return scope
}

func (scope CardScope) Or(scopes ...Scope) CardScope {
	c := condition{}
	ors := []string{}
	for _, oscope := range scopes {
		cond := []string{}
		conds := oscope.conds()
		if len(conds) == 1 {
			c.vals = append(c.vals, conds[0].vals...)
			ors = append(ors, conds[0].ToSQL())
		} else {
			for _, ocond := range conds {
				c.vals = append(c.vals, ocond.vals...)
				cond = append(cond, ocond.ToSQL())
			}
			ors = append(ors, "("+strings.Join(cond, " AND ")+")")
		}
	}
	c.cond = "(" + strings.Join(ors, " OR ") + ")"

	scope.conditions = append(scope.conditions, c)

	return scope
}

func (scope CardScope) ID() CardScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "ID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperCardToID struct {
	Mapper *mapperCard
}

func (m mapperCardToID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).ID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope CardScope) Name() CardScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "Name")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperCardToName struct {
	Mapper *mapperCard
}

func (m mapperCardToName) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Name = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Name = string(s)

	}

	return nil

}

func (scope CardScope) Type() CardScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "Type")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperCardToType struct {
	Mapper *mapperCard
}

func (m mapperCardToType) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Type = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Type = string(s)

	}

	return nil

}

func (scope CardScope) Data() CardScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "Data")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperCardToData struct {
	Mapper *mapperCard
}

func (m mapperCardToData) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Data = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Data = string(s)

	}

	return nil

}

func (scope CardScope) DeckID() CardScope {
	scope.currentColumn =
		scope.conn.SQLTable(scope.tableName()) +
			"." +
			scope.conn.SQLColumn(scope.tableName(), "DeckID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperCardToDeckID struct {
	Mapper *mapperCard
}

func (m mapperCardToDeckID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).DeckID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).DeckID = i

		return err
	}
	return nil

}

type mapperCard struct {
	Current  **Card
	Columns  []string
	Scanners []interface{}
}

func mapperForCard(scope CardScope) *mapperCard {
	m := &mapperCard{}
	m.Columns = []string{scope.tableName() + "." + scope.conn.SQLColumn("Card", "ID"), scope.tableName() + "." + scope.conn.SQLColumn("Card", "Name"), scope.tableName() + "." + scope.conn.SQLColumn("Card", "Type"), scope.tableName() + "." + scope.conn.SQLColumn("Card", "Data"), scope.tableName() + "." + scope.conn.SQLColumn("Card", "DeckID")}
	m.Scanners = []interface{}{

		mapperCardToID{m},

		mapperCardToName{m},

		mapperCardToType{m},

		mapperCardToData{m},

		mapperCardToDeckID{m},
	}

	return m
}

func (t Account) Deck(c *Conn) ([]Deck, error) {
	return t.DeckScope(c).RetrieveAll()
}
func (t Account) DeckScope(c *Conn) DeckScope {
	return c.Deck.AccountID().Eq(t.ID)
}
func (scope AccountScope) DeckScope() DeckScope {

	return DeckScope{scope.InnerJoin(scope.conn.Deck).internal()}

}

func (t Deck) Card(c *Conn) ([]Card, error) {
	return t.CardScope(c).RetrieveAll()
}
func (t Deck) CardScope(c *Conn) CardScope {
	return c.Card.DeckID().Eq(t.ID)
}
func (scope DeckScope) CardScope() CardScope {

	return CardScope{scope.InnerJoin(scope.conn.Card).internal()}

}

func (t Deck) Account(c *Conn) (Account, error) {
	return t.AccountScope(c).Retrieve()
}
func (t Deck) AccountScope(c *Conn) AccountScope {
	return c.Account.Eq(t.AccountID)
}
func (scope DeckScope) AccountScope() AccountScope {

	return AccountScope{scope.InnerJoin(scope.conn.Account).internal()}

}

func (t Card) Deck(c *Conn) (Deck, error) {
	return t.DeckScope(c).Retrieve()
}
func (t Card) DeckScope(c *Conn) DeckScope {
	return c.Deck.Eq(t.DeckID)
}
func (scope CardScope) DeckScope() DeckScope {

	return DeckScope{scope.InnerJoin(scope.conn.Deck).internal()}

}
