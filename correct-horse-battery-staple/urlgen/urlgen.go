package urlgen

import (
	"bytes"
	"math/rand"
	"time"
)

const (
	maxRooms = 64000
)

var alphabet string = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
var shuffledAlphabet []byte
var prime int64
var numberOfDigits int64
var generator int64

func init() {
	// Shuffle the alphabet
	rand.Seed(time.Now().UnixNano())
	shuffledAlphabet = make([]byte, len(alphabet))
	shuffle := rand.Perm(len(alphabet))

	for index, value := range shuffle {
		shuffledAlphabet[value] = alphabet[index]
	}

	// Figure out how many digits we need and the prime
	numberOfDigits = int64(1)
	var max int64
	for max = powInt(int64(len(alphabet)), numberOfDigits); max < maxRooms; {
		numberOfDigits++
		max = powInt(int64(len(alphabet)), numberOfDigits)
	}

	for ; !isPrime(max); max-- {
	}

	if max < maxRooms {
		numberOfDigits++
		max = powInt(int64(len(alphabet)), numberOfDigits)
		for ; !isPrime(max); max-- {
		}
	}

	prime = max
	generator = findGenerator()
}

func GetTokenFromId(id int64) string {
	id = powIntMod(generator, id, prime)
	return encode(id, numberOfDigits)
}

func GetIdFromToken(token string) int64 {
	number := decode(token)

	//TODO: This just brute forces the number. There is a better way
	for i := int64(0); ; i++ {
		canidate := powIntMod(generator, i, prime)
		if canidate == number {
			return i
		}
	}
}

func testGenerator(canidate int64) bool {
	primeMinusOne := prime - 1
	primeFactors := getUniquePrimeFactors(primeMinusOne)
	for _, primeFactor := range primeFactors {
		if powIntMod(canidate, (primeMinusOne/primeFactor), prime) == 1 {
			return false
		}
	}
	return true
}

func findGenerator() int64 {
	primeMinusOne := prime - 1
	for {
		canidate := rand.Int63n(primeMinusOne-1) + 2
		if testGenerator(canidate) {
			return canidate
		}
	}
}

// Encodes a number into the alphabet with the given length
func encode(number, numberOfDigits int64) string {
	codeLength := int64(len(alphabet))
	result := make([]byte, codeLength)
	var remainder int64

	for i := int64(0); i < numberOfDigits; i++ {
		number, remainder = divMod(number, codeLength)
		result[i] = shuffledAlphabet[remainder]
	}

	return string(result[:numberOfDigits])
}

// Decodes a token that was generated by encode back into a number
func decode(token string) int64 {
	number := int64(0)
	for i := int64(0); i < int64(len(token)); i++ {
		number += int64(bytes.IndexByte(shuffledAlphabet, token[i])) * powInt(int64(len(alphabet)), i)
	}
	return number
}
