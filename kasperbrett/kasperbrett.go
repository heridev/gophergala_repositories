package main

import (
	"bitbucket.org/kardianos/osext"
	"bytes"
	"encoding/gob"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/PuerkitoBio/goquery"
	"github.com/Unknwon/macaron"
	"github.com/boltdb/bolt"
	"github.com/googollee/go-socket.io"
	"github.com/macaron-contrib/binding"
	"github.com/nu7hatch/gouuid"
	"github.com/robertkrimen/otto"
	"github.com/stretchr/graceful"
	"github.com/stretchr/pat/stop"
	"github.com/ttacon/chalk"
	"gopkg.in/tomb.v2"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"
	"time"
)

func main() {
	// print some eye candy to standard out...
	fmt.Print(chalk.Yellow, "██╗  ██╗ █████╗ ███████╗██████╗ ███████╗██████╗ ", chalk.ResetColor)
	fmt.Println(chalk.Red, "██████╗ ██████╗ ███████╗████████╗████████╗", chalk.ResetColor)
	fmt.Print(chalk.Yellow, "██║ ██╔╝██╔══██╗██╔════╝██╔══██╗██╔════╝██╔══██╗", chalk.ResetColor)
	fmt.Println(chalk.Red, "██╔══██╗██╔══██╗██╔════╝╚══██╔══╝╚══██╔══╝", chalk.ResetColor)
	fmt.Print(chalk.Yellow, "█████╔╝ ███████║███████╗██████╔╝█████╗  ██████╔╝", chalk.ResetColor)
	fmt.Println(chalk.Red, "██████╔╝██████╔╝█████╗     ██║      ██║   ", chalk.ResetColor)
	fmt.Print(chalk.Yellow, "██╔═██╗ ██╔══██║╚════██║██╔═══╝ ██╔══╝  ██╔══██╗", chalk.ResetColor)
	fmt.Println(chalk.Red, "██╔══██╗██╔══██╗██╔══╝     ██║      ██║   ", chalk.ResetColor)
	fmt.Print(chalk.Yellow, "██║  ██╗██║  ██║███████║██║     ███████╗██║  ██║", chalk.ResetColor)
	fmt.Println(chalk.Red, "██████╔╝██║  ██║███████╗   ██║      ██║   ", chalk.ResetColor)
	fmt.Print(chalk.Yellow, "╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝     ╚══════╝╚═╝  ╚═╝", chalk.ResetColor)
	fmt.Print(chalk.Red, " ╚═════╝ ╚═╝  ╚═╝╚══════╝   ╚═╝      ╚═╝   ", chalk.ResetColor)
	fmt.Println(chalk.Yellow, "v0.0.1", chalk.ResetColor)

	// config file discovery
	configFilePath, err := getConfigFilePath()
	if err != nil {
		fmt.Println("Error while discovering config file:", err)
		os.Exit(1)
	}

	// config processing
	config, err := processConfig(configFilePath)
	if err != nil {
		fmt.Println("Error while processing config file:", err)
		os.Exit(2)
	}
	fmt.Println("config ->", config.GetPort(), config.GetDataFilePath(), config.GetDataFlushInterval())

	// orchestration
	kasperbrett, err := NewKasperbrett(config).Prepare()
	if err != nil {
		fmt.Println("Couldn't start Kasperbrett server. Reason:", err)
		os.Exit(3)
	}

	// prevent main() from terminating
	kasperbrett.BlockUntilShutdown()
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* *****  ██████╗ ██████╗ ███╗   ██╗███████╗██╗ ██████╗ ██╗   ██╗██████╗  █████╗ ████████╗██╗ ██████╗ ███╗   ██╗ ***** */
/* ***** ██╔════╝██╔═══██╗████╗  ██║██╔════╝██║██╔════╝ ██║   ██║██╔══██╗██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║ ***** */
/* ***** ██║     ██║   ██║██╔██╗ ██║█████╗  ██║██║  ███╗██║   ██║██████╔╝███████║   ██║   ██║██║   ██║██╔██╗ ██║ ***** */
/* ***** ██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║   ██║██║   ██║██╔══██╗██╔══██║   ██║   ██║██║   ██║██║╚██╗██║ ***** */
/* ***** ╚██████╗╚██████╔╝██║ ╚████║██║     ██║╚██████╔╝╚██████╔╝██║  ██║██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║ ***** */
/* *****  ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝ ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag ***** ***** ***** ***** ***** ***** ****** ***** */

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type Config interface {
	GetPort() int
	GetDataFilePath() string
	GetDataFlushInterval() int
}

type KasperbrettConfig struct {
	Port              int
	DataFilePath      string
	DataFlushInterval int
}

func (c *KasperbrettConfig) GetPort() int {
	return c.Port
}

func (c *KasperbrettConfig) GetDataFilePath() string {
	return c.DataFilePath
}

func (c *KasperbrettConfig) GetDataFlushInterval() int {
	return c.DataFlushInterval
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

const ConfigFileName = "config.json"

func getConfigFilePath() (string, error) {
	var path string

	if len(os.Args) > 1 {
		args := os.Args[1:]
		configArgFound := false
		for i, arg := range args {
			if arg == "-c" || arg == "--config" {
				configArgFound = true

				if len(args)-1 > i {
					path = args[i+1]
				}
			}
		}

		if configArgFound {
			if len(path) == 0 {
				return "", errors.New("Invalid config path.")
			}

			if !fileExists(path) {
				return "", fmt.Errorf("Couldn't find config file at '%s'.", path)
			}

			return path, nil
		}
	}

	kasperbrettPath, err := osext.ExecutableFolder()
	if err != nil {
		return "", err
	}

	defaultConfigFilePath := fmt.Sprintf("%s%s", kasperbrettPath, ConfigFileName)
	if !fileExists(defaultConfigFilePath) {
		errMsg := "\nSome genius has been dump enough to delete the default config (%s).\n" +
			"Please restore it or provide another one via --config CONFIG_PATH (or -c CONFIG_PATH). " +
			"Relative (to CWD) and absolute paths are allowed."
		return "", fmt.Errorf(errMsg, defaultConfigFilePath)
	}

	return defaultConfigFilePath, nil
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

func processConfig(configFilePath string) (Config, error) {
	configFile, err := os.Open(configFilePath)
	if err != nil {
		return nil, err
	}

	decoder := json.NewDecoder(configFile)
	config := &KasperbrettConfig{}
	err = decoder.Decode(config)
	if err != nil {
		return nil, err
	}

	if !strings.HasPrefix(config.DataFilePath, "/") {
		kasperbrettPath, err := osext.ExecutableFolder()
		if err != nil {
			return nil, err
		}

		config.DataFilePath = fmt.Sprintf("%s%s", kasperbrettPath, config.DataFilePath)
	}

	return config, nil
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* *****  ██████╗ ██████╗  ██████╗██╗  ██╗███████╗███████╗████████╗██████╗  █████╗ ████████╗██╗ ██████╗ ███╗   ██╗ ***** */
/* ***** ██╔═══██╗██╔══██╗██╔════╝██║  ██║██╔════╝██╔════╝╚══██╔══╝██╔══██╗██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║ ***** */
/* ***** ██║   ██║██████╔╝██║     ███████║█████╗  ███████╗   ██║   ██████╔╝███████║   ██║   ██║██║   ██║██╔██╗ ██║ ***** */
/* ***** ██║   ██║██╔══██╗██║     ██╔══██║██╔══╝  ╚════██║   ██║   ██╔══██╗██╔══██║   ██║   ██║██║   ██║██║╚██╗██║ ***** */
/* ***** ╚██████╔╝██║  ██║╚██████╗██║  ██║███████╗███████║   ██║   ██║  ██║██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║ ***** */
/* *****  ╚═════╝ ╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝ ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag ***** ***** ***** ***** ***** ***** ***** ** ***** */

// TODO: Refactor this section to a separate package!
// TODO: Add test cases

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewKasperbrett(config Config) *Kasperbrett {
	kb := &Kasperbrett{
		config:        config,
		osSignalsChan: make(chan os.Signal),
		shutdownChan:  make(chan error),
	}

	signal.Notify(kb.osSignalsChan, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		signal := <-kb.osSignalsChan
		fmt.Println("\nShutting down Kasperbrett server due to:", signal)
		// this is valid because we are using 'graceful' package
		fmt.Println("Giving currently active HTTP requests 10 seconds to finish...")

		err := kb.ShutDown()
		if err != nil {
			fmt.Println("Couldn't gracefully shut down Kasperbrett server. Reason:", err)
		}
		kb.shutdownChan <- err
	}()

	return kb
}

type Kasperbrett struct {
	config          Config
	osSignalsChan   chan os.Signal
	shutdownChan    chan error
	reportingEngine ReportingEngine
	scheduler       Scheduler
	restApi         RestApi
	socketIOApi     SocketIOApi
}

func (kb *Kasperbrett) Prepare() (*Kasperbrett, error) {
	kasperbrettExecFolderPath, err := osext.ExecutableFolder()
	if err != nil {
		return nil, err
	}

	fmt.Println("kasperbrettExecFolderPath ->", kasperbrettExecFolderPath)

	kb.socketIOApi, err = NewKasperbrettSocketIOApi()
	if err != nil {
		return nil, err
	}

	boltDataStore := NewBoltDataStore(kb.config.GetDataFilePath())
	persistentDataStoreReporter := NewPersistentDataStoreReporter(boltDataStore, time.Second*time.Duration(kb.config.GetDataFlushInterval()))

	kb.reportingEngine = NewKasperbrettReportingEngine()
	kb.reportingEngine.Register(
		NewConsoleReporter("[ConsoleReporter] "),
		NewSocketIOReporter(kb.socketIOApi),
		persistentDataStoreReporter,
	)

	kb.scheduler = NewKasperbrettScheduler(kb.reportingEngine)

	/*urlScraperDs, err := NewUrlScraper(
		"http://angularjs.de",
		"body > div > div:nth-child(4) > div.col-sm-6.col-md-5 > ul:nth-child(6) > li:nth-child(5) > span",
		"value.substr(0, value.length - 1)",
	)
	if err != nil {
		return nil, err
	}

	kb.scheduler.Schedule(urlScraperDs.Id(), time.Millisecond*10000, func(reportingEngine ReportingEngine) {
		RetrieveAndDistribute(urlScraperDs, reportingEngine, 3000*time.Millisecond)
	})
	*/

	portString := ":" + strconv.Itoa(kb.config.GetPort())

	kb.restApi = NewKasperbrettRestApi(portString, "/realtime/", kb.socketIOApi, boltDataStore, persistentDataStoreReporter, kb.scheduler)
	bindErrChan := kb.restApi.ListenAndServe()
	bindErr := <-bindErrChan
	if bindErr != nil {
		return nil, bindErr
	}

	return kb, nil
}

func (kb *Kasperbrett) ShutDown() error {
	_, schedulerShutDownErrChan := kb.scheduler.ShutDown()
	schedulerShutDownErr := <-schedulerShutDownErrChan

	reportingEngineShutDownErr := kb.reportingEngine.ShutDown()

	if schedulerShutDownErr != nil {
		return schedulerShutDownErr
	} else if reportingEngineShutDownErr != nil {
		return reportingEngineShutDownErr
	} else {
		return nil
	}
}

func (kb *Kasperbrett) BlockUntilShutdown() stop.Signal {
	stopChan := kb.restApi.StopChan()
	<-kb.shutdownChan
	return <-stopChan
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ██████╗ ███████╗███████╗████████╗    ██╗███╗   ██╗████████╗███████╗██████╗ ███████╗ █████╗  ██████╗███████╗ ***** */
/* ***** ██╔══██╗██╔════╝██╔════╝╚══██╔══╝    ██║████╗  ██║╚══██╔══╝██╔════╝██╔══██╗██╔════╝██╔══██╗██╔════╝██╔════╝ ***** */
/* ***** ██████╔╝█████╗  ███████╗   ██║       ██║██╔██╗ ██║   ██║   █████╗  ██████╔╝█████╗  ███████║██║     █████╗   ***** */
/* ***** ██╔══██╗██╔══╝  ╚════██║   ██║       ██║██║╚██╗██║   ██║   ██╔══╝  ██╔══██╗██╔══╝  ██╔══██║██║     ██╔══╝   ***** */
/* ***** ██║  ██║███████╗███████║   ██║       ██║██║ ╚████║   ██║   ███████╗██║  ██║██║     ██║  ██║╚██████╗███████╗ ***** */
/* ***** ╚═╝  ╚═╝╚══════╝╚══════╝   ╚═╝       ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝ ╚═════╝╚══════╝ ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag ***** ***** ***** ***** ***** ***** ***** **** ***** */

// TODO: Refactor this section to a separate package!
// TODO: Add test cases

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type RestApi interface {
	ListenAndServe() chan error
	StopChan() <-chan stop.Signal
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type DataSourceDto struct {
	// Id is only set for the corresponding GET requests
	Id       string `json:"id"`
	Type     string `json:"type" binding:"Required"`
	Name     string `json:"name" binding:"Required"`
	Interval int64  `json:"interval"`
	Timeout  int64  `json:"timeout"`
	// TypeSettings are variable depending on the data source
	TypeSettings map[string]string `json:"typeSettings"`
	// Labels and Series are only set if query param `include-data` is set to 1 (GET /datasources)
	Labels []int64  `json:"labels"` // int64 because it represents the number of milliseconds since Unix Epoch
	Series []string `json:"series"` // string because Kasperbrett considers sample values as strings
}

type DataSourceResponse struct {
	DataSourceId string `json:"dataSourceId"`
	Timestamp    int64  `json:"timestamp"`
	Value        string `json:"value"`
}

type DataSourceTestResponse struct {
	Value string `json:"value"`
}

type ErrorResponse struct {
	Error string `json:"error"`
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

// TODO: PersistentDataStoreReporter might become an interface.
func NewKasperbrettRestApi(bindAddr string, socketIOPath string, socketIOApi SocketIOApi, dataStore DataStore, persistentDataStoreReporter *PersistentDataStoreReporter, scheduler Scheduler) *KasperbrettRestApi {
	mux := http.NewServeMux()

	m := macaron.Classic()
	m.Use(macaron.Renderer()) // add JSON rendering ability

	m.Group("/api", func() {
		m.Post("/datasources", binding.Bind(DataSourceDto{}), func(ds DataSourceDto, ctx *macaron.Context) {
			// basic validation
			if ds.Type != DsUrlScraper {
				ctx.JSON(400, &ErrorResponse{Error: "Unsupported data source type: " + ds.Type})
				return
			}
			if len(ds.TypeSettings["url"]) == 0 {
				ctx.JSON(400, &ErrorResponse{Error: "Please provide a valid URL."})
				return
			}
			if len(ds.TypeSettings["cssPath"]) == 0 {
				ctx.JSON(400, &ErrorResponse{Error: "Please provide a valid CSS path."})
				return
			}
			if ds.Interval < 30000 {
				ctx.JSON(400, &ErrorResponse{Error: "Please provide a bigger interval (>= 30000) to prevent abuse."})
				return
			}

			// default values
			if ds.Interval == 0 {
				ds.Interval = 60000 // 1 min
			}
			if ds.Timeout == 0 {
				ds.Timeout = 10000 // 10 sec
			}

			// data source creation
			abstractDataSource, err := NewAbstractDataSource(
				ds.Name, time.Duration(ds.Interval)*time.Millisecond, time.Duration(ds.Timeout)*time.Millisecond,
			)
			if err != nil {
				ctx.JSON(400, &ErrorResponse{Error: err.Error()})
				return
			}

			urlScraperDs := NewUrlScraper(
				abstractDataSource, ds.TypeSettings["url"], ds.TypeSettings["cssPath"], ds.TypeSettings["transformationScript"],
			)

			// retrieval test
			sample := Retrieve(urlScraperDs, time.Duration(ds.Timeout)*time.Millisecond)
			if sample.Err != nil {
				ctx.JSON(400, &ErrorResponse{Error: sample.Err.Error()})
				return
			}

			retrievalTestOnly := ctx.Query("test-only")
			if retrievalTestOnly == "1" {
				ctx.JSON(200, &DataSourceTestResponse{Value: sample.Value})
				return
			}

			// persist data source
			err = dataStore.PersistDataSource(urlScraperDs)
			if err != nil {
				ctx.JSON(400, &ErrorResponse{Error: err.Error()})
				return
			}

			// schedule data source job
			scheduler.Schedule(urlScraperDs.Id(), time.Millisecond*time.Duration(ds.Interval), func(reportingEngine ReportingEngine) {
				RetrieveAndDistribute(urlScraperDs, reportingEngine, time.Duration(ds.Timeout)*time.Millisecond)
			})

			ctx.JSON(200, &DataSourceResponse{DataSourceId: urlScraperDs.Id(), Timestamp: sample.Timestamp.UnixNano() / 1000000, Value: sample.Value})
		})

		m.Get("/datasources/:dataSourceId/samples/:timeframe", func(ctx *macaron.Context) string {
			dataSourceId := ctx.Params(":dataSourceId")
			timeframeStr := ctx.Params(":timeframe")

			if len(dataSourceId) == 0 {
				return "Please provide a valid dataSourceId."
			}

			if len(timeframeStr) == 0 {
				return "Please provide a valid timeframe."
			}

			if !strings.HasPrefix(timeframeStr, "now-") {
				return "A valid timeframe has to start with 'now-' followed by a duration. (e.g. 'now-1h30m')"
			}

			timeframeParts := strings.Split(timeframeStr, "-")
			if len(timeframeParts) != 2 {
				return "A valid timeframe has to start with 'now-' followed by a duration. (e.g. 'now-2h30m')"
			}

			duration, err := time.ParseDuration(timeframeParts[1])
			if err != nil {
				return "Invalid duration: " + timeframeParts[1]
			}

			to := time.Now()
			from := to.Add(-1 * duration)

			samples, err := dataStore.GetSamples(dataSourceId, from, to)
			if err != nil {
				return "An error occurred during sample retrieval: " + err.Error()
			} else {
				bufferedSamples := persistentDataStoreReporter.GetSamples(dataSourceId, from, to)
				samples := append(samples, bufferedSamples...)
				return fmt.Sprintf("I've found %d matching samples.", len(samples))
			}
		})

		m.Get("/datasources", func(ctx *macaron.Context) {
			dataSources, err := dataStore.GetDataSources()
			if err != nil {
				ctx.JSON(500, &ErrorResponse{Error: err.Error()})
				return
			}

			includeLatestSamples := ctx.Query("include-latest-samples")

			var dataSourceDto DataSourceDto
			var urlScraperDs *UrlScraper
			dataSourceList := []DataSourceDto{}
			for _, dataSource := range dataSources {
				// TODO: differentiate between multiple data sources in the future
				urlScraperDs = dataSource.(*UrlScraper)

				dataSourceDto = DataSourceDto{
					Type:     DsUrlScraper,
					Id:       dataSource.Id(),
					Name:     dataSource.Name(),
					Interval: dataSource.Interval().Nanoseconds() / 1000000,
					Timeout:  dataSource.Timeout().Nanoseconds() / 1000000,
					TypeSettings: map[string]string{
						"url":                  urlScraperDs.url,
						"cssPath":              urlScraperDs.cssPath,
						"transformationScript": urlScraperDs.transformationScript,
					},
				}

				if includeLatestSamples == "1" {
					desiredNumOfSamples := 10
					samples := persistentDataStoreReporter.GetLatestSamples(dataSource.Id(), desiredNumOfSamples)
					if len(samples) < desiredNumOfSamples {
						storedSamples, err := dataStore.GetLatestSamples(dataSource.Id(), desiredNumOfSamples-len(samples))
						if err != nil {
							ctx.JSON(500, &ErrorResponse{Error: err.Error()})
							return
						}

						samples = append(storedSamples, samples...)
					}

					labels := []int64{}
					series := []string{}
					for _, sample := range samples {
						labels = append(labels, sample.Timestamp.UnixNano()/1000000)
						series = append(series, sample.Value)
					}
					dataSourceDto.Labels = labels
					dataSourceDto.Series = series
				}

				dataSourceList = append(dataSourceList, dataSourceDto)
			}

			ctx.JSON(200, &dataSourceList)
		})

		// just a trigger to test dataStore.GetSamples()
		m.Get("/trigger-get-samples", func() string {
			// 2015-01-18T14:36:51.915246044Z
			from, fromErr := time.Parse(time.RFC3339Nano, "2015-01-18T14:36:51Z")
			if fromErr != nil {
				fmt.Println("An error occurred during parsing of from time:", fromErr)
			}

			to, toErr := time.Parse(time.RFC3339Nano, "2015-01-18T14:37:08Z")
			if toErr != nil {
				fmt.Println("An error occurred during parsing of to time:", toErr)
			}

			samples, err := dataStore.GetSamples("ds-fcb12ecc-b067-46d8-44be-48f3d70ea458", from, to)
			if err != nil {
				fmt.Println("An error occurred (GET /datasources) ->", err)
			} else {
				for _, sample := range samples {
					fmt.Println("      [AFTER Sample]      ", sample)
				}
			}

			return "Done!"
		})
	})

	mux.Handle(socketIOPath, socketIOApi.Handler())
	mux.Handle("/", m)

	httpServer := &graceful.Server{
		Timeout: 10 * time.Second,
		Server: &http.Server{
			Addr:    bindAddr,
			Handler: mux,
		},
	}

	return &KasperbrettRestApi{macaron: m, httpServer: httpServer, dataStore: dataStore}
}

type KasperbrettRestApi struct {
	macaron    *macaron.Macaron
	httpServer *graceful.Server
	dataStore  DataStore
}

func (rest *KasperbrettRestApi) ListenAndServe() chan error {
	responseChan := make(chan error)

	go func() {
		timeoutTicker := time.NewTicker(time.Second * 3)
		<-timeoutTicker.C
		responseChan <- nil
	}()

	go func() {
		err := rest.httpServer.ListenAndServe()
		if err != nil {
			responseChan <- err
		}
	}()

	return responseChan
}

func (rest *KasperbrettRestApi) StopChan() <-chan stop.Signal {
	return rest.httpServer.StopChan()
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ███████╗ ██████╗  ██████╗██╗  ██╗███████╗████████╗██╗ ██████╗  ***** */
/* ***** ██╔════╝██╔═══██╗██╔════╝██║ ██╔╝██╔════╝╚══██╔══╝██║██╔═══██╗ ***** */
/* ***** ███████╗██║   ██║██║     █████╔╝ █████╗     ██║   ██║██║   ██║ ***** */
/* ***** ╚════██║██║   ██║██║     ██╔═██╗ ██╔══╝     ██║   ██║██║   ██║ ***** */
/* ***** ███████║╚██████╔╝╚██████╗██║  ██╗███████╗   ██║██╗██║╚██████╔╝ ***** */
/* ***** ╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝   ╚═╝╚═╝╚═╝ ╚═════╝  ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag * ***** */

// TODO: Refactor this section to a separate package!
// TODO: Add test cases

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type SocketIOApi interface {
	Handler() http.Handler
	Broadcast(*Sample)
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewKasperbrettSocketIOApi() (*KasperbrettSocketIOApi, error) {
	ioServer, err := socketio.NewServer(nil)
	if err != nil {
		return nil, err
	}

	ioServer.On("connection", func(so socketio.Socket) {
		fmt.Println("on connection")
		so.Join("sample")

		/*so.On("chat message", func(msg string) {
			fmt.Println("emit:", so.Emit("chat message", msg))
			so.BroadcastTo("chat", "chat message", msg)
		})
		*/
		so.On("disconnection", func() {
			fmt.Println("on disconnect")
		})
	})
	ioServer.On("error", func(so socketio.Socket, err error) {
		fmt.Println("error:", err)
	})

	return &KasperbrettSocketIOApi{ioServer: ioServer}, nil
}

type KasperbrettSocketIOApi struct {
	ioServer *socketio.Server
}

func (io *KasperbrettSocketIOApi) Handler() http.Handler {
	return io.ioServer
}

func (io *KasperbrettSocketIOApi) Broadcast(sample *Sample) {
	io.ioServer.BroadcastTo("sample", "new_sample", sample.JSON())
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ██████╗  █████╗ ████████╗ █████╗     ███████╗████████╗ ██████╗ ██████╗  █████╗  ██████╗ ███████╗ ***** */
/* ***** ██╔══██╗██╔══██╗╚══██╔══╝██╔══██╗    ██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗██╔══██╗██╔════╝ ██╔════╝ ***** */
/* ***** ██║  ██║███████║   ██║   ███████║    ███████╗   ██║   ██║   ██║██████╔╝███████║██║  ███╗█████╗   ***** */
/* ***** ██║  ██║██╔══██║   ██║   ██╔══██║    ╚════██║   ██║   ██║   ██║██╔══██╗██╔══██║██║   ██║██╔══╝   ***** */
/* ***** ██████╔╝██║  ██║   ██║   ██║  ██║    ███████║   ██║   ╚██████╔╝██║  ██║██║  ██║╚██████╔╝███████╗ ***** */
/* ***** ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝    ╚══════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝ ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag ***** ***** ***** ***** ***** ***** ***** */

// TODO: Refactor this section to a separate package!
// TODO: Add test cases

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type DataStore interface {
	Prepare() error
	ShutDown() error
	PersistDataSource(dataSource DataSource) error
	GetDataSources() ([]DataSource, error)
	PersistSamples(samples []*Sample) error
	GetSamples(dataSourceId string, from time.Time, to time.Time) ([]*Sample, error)
	GetLatestSamples(dataSourceId string, num int) ([]*Sample, error)
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

const (
	BoltDataFileName       = "kasperbrett.db"
	BoltSamplesBucket      = "KasperbrettSamples"
	BoltDataSourcesBucket  = "KasperbrettDataSources"
	BoltSampleKeySeparator = "#"
)

func NewBoltDataStore(dataFileAbsPath string) *BoltDataStore {
	return &BoltDataStore{dataFileAbsPath: dataFileAbsPath}
}

type BoltDataStore struct {
	dataFileAbsPath string
	db              *bolt.DB
}

func (ds *BoltDataStore) Prepare() error {
	fmt.Println("[BoltDataStore] Prepare()")
	db, err := bolt.Open(ds.dataFileAbsPath, 0600, &bolt.Options{Timeout: 10 * time.Second})
	if err != nil {
		return err
	}

	ds.db = db

	err = ds.createBucketIfNotExists(BoltSamplesBucket)
	if err != nil {
		return err
	}

	return ds.createBucketIfNotExists(BoltDataSourcesBucket)
}

func (ds *BoltDataStore) ShutDown() error {
	fmt.Println("[BoltDataStore] ShutDown()")
	return ds.db.Close()
}

func (ds *BoltDataStore) PersistDataSource(dataSource DataSource) error {
	return ds.db.Update(func(tx *bolt.Tx) error {
		fmt.Printf("[BoltDataStore] Persisting data source %s\n", dataSource.Id())
		b := tx.Bucket([]byte(BoltDataSourcesBucket))
		dataSourceBytes, err := dataSource.GobEncode()
		if err != nil {
			return err
		}

		return b.Put([]byte(dataSource.Id()), dataSourceBytes)
	})
}

func (ds *BoltDataStore) GetDataSources() ([]DataSource, error) {
	dataSources := []DataSource{}

	err := ds.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(BoltDataSourcesBucket))

		var dataSource DataSource
		var err error
		return b.ForEach(func(dataSourceId, dataSourceBytes []byte) error {
			// TODO: we need to differentiate between different data source types here
			dataSource = new(UrlScraper)
			err = dataSource.GobDecode(dataSourceBytes)
			if err != nil {
				fmt.Printf("[BoltDataStore.GetDataSources()] Couldn't read data source %s due to: %s\n", dataSourceId, err.Error())
			} else {
				dataSources = append(dataSources, dataSource)
			}

			return nil
		})
	})

	if err != nil {
		return nil, err
	} else {
		return dataSources, nil
	}
}

func (ds *BoltDataStore) PersistSamples(samples []*Sample) error {
	return ds.db.Update(func(tx *bolt.Tx) error {
		fmt.Printf("[BoltDataStore] Persisting %d samples\n", len(samples))
		b := tx.Bucket([]byte(BoltSamplesBucket))

		var overallError error = nil

		for _, sample := range samples {
			fmt.Printf("[BoltDataStore] Persisting sample %s (%s)\n", sample.Key(), sample.String())
			sampleBytes, err := sample.GobEncode()
			if err != nil {
				if overallError == nil {
					overallError = err
				}
			} else {
				err := b.Put([]byte(sample.Key()), sampleBytes)
				if err != nil && overallError == nil {
					overallError = err
				}
			}
		}

		return overallError
	})
}

func (ds *BoltDataStore) GetSamples(dataSourceId string, from time.Time, to time.Time) ([]*Sample, error) {
	samples := []*Sample{}

	err := ds.db.View(func(tx *bolt.Tx) error {
		c := tx.Bucket([]byte(BoltSamplesBucket)).Cursor()
		min := []byte(GenerateKey(dataSourceId, BoltSampleKeySeparator, from))
		max := []byte(GenerateKey(dataSourceId, BoltSampleKeySeparator, to))

		fmt.Printf(" [BoltDataStore.GetSamples()] from -> %s ||| to -> %s\n", from.UTC().Format(time.RFC3339Nano), to.UTC().Format(time.RFC3339Nano))

		var err error
		var sample *Sample
		for k, sampleBytes := c.Seek(min); k != nil && bytes.Compare(k, max) <= 0; k, sampleBytes = c.Next() {
			sample = new(Sample)
			err = sample.GobDecode(sampleBytes)
			if err != nil {
				fmt.Printf("[BoltDataStore.GetSamples()] Couldn't read sample %s due to: %s\n", k, err.Error())
			} else {
				samples = append(samples, sample)
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	} else {
		return samples, nil
	}
}

func (ds *BoltDataStore) GetLatestSamples(dataSourceId string, num int) ([]*Sample, error) {
	samples := []*Sample{}

	err := ds.db.View(func(tx *bolt.Tx) error {
		c := tx.Bucket([]byte(BoltSamplesBucket)).Cursor()
		dataSourceIdBytes := []byte(dataSourceId)

		var err error
		var sample *Sample
		for k, sampleBytes := c.Last(); k != nil && len(samples) < num; k, sampleBytes = c.Prev() {
			if bytes.HasPrefix(k, dataSourceIdBytes) {
				sample = new(Sample)
				err = sample.GobDecode(sampleBytes)
				if err != nil {
					fmt.Printf("[BoltDataStore.GetLatestSamples()] Couldn't read sample %s due to: %s\n", k, err.Error())
				} else {
					samples = append(samples, sample)
				}
			}
		}

		// reverse order
		samplesCount := len(samples)
		if samplesCount > 0 {
			ascOrderSamples := make([]*Sample, len(samples))
			for i := samplesCount - 1; i >= 0; i-- {
				ascOrderSamples[samplesCount-(i+1)] = samples[i]
			}

			samples = ascOrderSamples
		}

		return nil
	})

	if err != nil {
		return nil, err
	} else {
		return samples, nil
	}
}

func (ds *BoltDataStore) createBucketIfNotExists(bucketName string) error {
	return ds.db.Update(func(tx *bolt.Tx) error {
		_, err := tx.CreateBucketIfNotExists([]byte(bucketName))
		if err != nil {
			return fmt.Errorf("create bucket: %s", err)
		}
		return nil
	})
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ██████╗  █████╗ ████████╗ █████╗     ██████╗ ███████╗████████╗██████╗ ██╗███████╗██╗   ██╗ █████╗ ██╗      ***** */
/* ***** ██╔══██╗██╔══██╗╚══██╔══╝██╔══██╗    ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██║██╔════╝██║   ██║██╔══██╗██║      ***** */
/* ***** ██║  ██║███████║   ██║   ███████║    ██████╔╝█████╗     ██║   ██████╔╝██║█████╗  ██║   ██║███████║██║      ***** */
/* ***** ██║  ██║██╔══██║   ██║   ██╔══██║    ██╔══██╗██╔══╝     ██║   ██╔══██╗██║██╔══╝  ╚██╗ ██╔╝██╔══██║██║      ***** */
/* ***** ██████╔╝██║  ██║   ██║   ██║  ██║    ██║  ██║███████╗   ██║   ██║  ██║██║███████╗ ╚████╔╝ ██║  ██║███████╗ ***** */
/* ***** ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝    ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝╚══════╝  ╚═══╝  ╚═╝  ╚═╝╚══════╝ ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag ***** ***** ***** ***** ***** ***** ***** *** ***** */

// TODO: Refactor this section to a separate package!
// TODO: Add test cases

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type DataSource interface {
	gob.GobEncoder
	gob.GobDecoder
	Retrieve(sampleChan chan *Sample)
	Id() string
	Type() string
	Name() string
	Interval() time.Duration
	Timeout() time.Duration
}

const (
	DsUrlScraper = "DsUrlScraper"
)

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func Retrieve(ds DataSource, timeout time.Duration) *Sample {
	sampleChan := make(chan *Sample)
	go ds.Retrieve(sampleChan)

	var sample *Sample

	select {
	case sample = <-sampleChan:
	case now := <-time.After(timeout):
		sample = NewSample("", now, ds.Id(), errors.New("Sample retrieval timed out."))
	}

	return sample
}

func RetrieveAndDistribute(ds DataSource, re ReportingEngine, timeout time.Duration) {
	sample := Retrieve(ds, timeout)
	re.Distribute(sample)
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewAbstractDataSource(name string, interval time.Duration, timeout time.Duration) (AbstractDataSource, error) {
	uuid, err := uuid.NewV4()
	if err != nil {
		return AbstractDataSource{}, err
	}

	dataSourceId := "ds-" + uuid.String()

	return AbstractDataSource{
		dataSourceId: dataSourceId,
		name:         name,
		interval:     interval,
		timeout:      timeout,
	}, nil
}

type AbstractDataSource struct {
	dataSourceId string
	name         string
	interval     time.Duration
	timeout      time.Duration
}

func (this AbstractDataSource) Id() string {
	return this.dataSourceId
}

func (this AbstractDataSource) Name() string {
	return this.name
}

func (this AbstractDataSource) Interval() time.Duration {
	return this.interval
}

func (this AbstractDataSource) Timeout() time.Duration {
	return this.timeout
}

func (this *AbstractDataSource) GobEncode() ([]byte, error) {
	// TODO: It might make sense to include a version number in the encoding due to future changes.

	fmt.Println("   [AbstractDataSource]   GobEncode()")

	buff := new(bytes.Buffer)
	encoder := gob.NewEncoder(buff)

	err := encoder.Encode(this.dataSourceId)
	if err != nil {
		return nil, err
	}

	err = encoder.Encode(this.name)
	if err != nil {
		return nil, err
	}

	err = encoder.Encode(this.interval)
	if err != nil {
		return nil, err
	}

	err = encoder.Encode(this.timeout)
	if err != nil {
		return nil, err
	}

	return buff.Bytes(), nil
}

func (this *AbstractDataSource) GobDecode(abstractDataSourceBytes []byte) error {
	// TODO: It might make sense to include a version number in the encoding due to future changes.
	fmt.Println("   [AbstractDataSource]   GobDecode()")

	buff := bytes.NewBuffer(abstractDataSourceBytes)
	decoder := gob.NewDecoder(buff)

	err := decoder.Decode(&this.dataSourceId)
	if err != nil {
		return err
	}

	err = decoder.Decode(&this.name)
	if err != nil {
		return err
	}

	err = decoder.Decode(&this.interval)
	if err != nil {
		return err
	}

	err = decoder.Decode(&this.timeout)
	if err != nil {
		return err
	}

	return nil
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func GenerateKey(dataSourceId string, keySeparator string, timestamp time.Time) string {
	// Due to the characteristics of Bolt (it stores keys in byte-sorted order) we use a time format that is sortable (RFC3339).
	// Additionally, when it comes to time we want to be as precise as possible.
	// And we need to avoid key collisions in case a data source has a very short retrieval interval (< 1s).
	// Therefore we use RFC3339Nano instead of simple RFC3339.
	// Furthermore, bucket keys should be based on reference time instead of local time. That's why we choose UTC.
	return fmt.Sprintf("%s%s%s", dataSourceId, keySeparator, timestamp.UTC().Format(time.RFC3339Nano))
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewSample(value string, timestamp time.Time, dataSourceId string, err error) *Sample {
	if len(dataSourceId) == 0 {
		panic("A Sample must have a valid dataSourceId.")
	}

	if len(value) == 0 && err == nil {
		panic("A Sample must have a valid value or a specified error.")
	}

	return &Sample{
		Value:        value,
		Timestamp:    timestamp,
		DataSourceId: dataSourceId,
		Err:          err,
	}
}

type Sample struct {
	Value        string
	Timestamp    time.Time
	DataSourceId string
	Err          error
}

func (this *Sample) JSON() string {
	/*b, err := json.Marshal(this)
	if err != nil {
		// TODO: log this misbehaviour
		return "{}"
	}*/

	json := fmt.Sprintf("{\"dataSourceId\":\"%s\", \"timestamp\":%d, \"value\":\"%s\"}", this.DataSourceId, this.Timestamp.UnixNano()/1000000, this.Value)

	return json
}

func (this *Sample) Key() string {
	return GenerateKey(this.DataSourceId, BoltSampleKeySeparator, this.Timestamp)
}

func (this *Sample) GobEncode() ([]byte, error) {
	// TODO: It might make sense to include a version number in the encoding due to future changes.

	buff := new(bytes.Buffer)
	encoder := gob.NewEncoder(buff)

	err := encoder.Encode(this.Value)
	if err != nil {
		return nil, err
	}

	err = encoder.Encode(this.Timestamp)
	if err != nil {
		return nil, err
	}

	err = encoder.Encode(this.DataSourceId)
	if err != nil {
		return nil, err
	}

	errStr := ""
	if this.Err != nil {
		errStr = this.Err.Error()
	}

	err = encoder.Encode(errStr)
	if err != nil {
		return nil, err
	}

	return buff.Bytes(), nil
}

func (this *Sample) GobDecode(sampleBytes []byte) error {
	// TODO: It might make sense to include a version number in the encoding due to future changes.
	fmt.Println("   [Sample]   GobDecode()")

	buff := bytes.NewBuffer(sampleBytes)
	decoder := gob.NewDecoder(buff)

	err := decoder.Decode(&this.Value)
	if err != nil {
		return err
	}

	err = decoder.Decode(&this.Timestamp)
	if err != nil {
		return err
	}

	err = decoder.Decode(&this.DataSourceId)
	if err != nil {
		return err
	}

	var str string
	err = decoder.Decode(&str)
	if err != nil {
		return err
	}

	if len(str) > 0 {
		this.Err = errors.New(str)
	} else {
		this.Err = nil
	}

	return nil
}

func (this *Sample) String() string {
	if len(this.Value) > 0 {
		return fmt.Sprintf("[%s] -> %s", this.Timestamp.UTC().Format(time.RFC1123Z), this.Value)
	} else {
		return fmt.Sprintf("[%s] -> %s", this.Timestamp.UTC().Format(time.RFC1123Z), this.Err)
	}
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewUrlScraper(abstractDataSource AbstractDataSource, url string, cssPath string, transformationScript string) *UrlScraper {
	return &UrlScraper{
		AbstractDataSource:   abstractDataSource,
		url:                  url,
		cssPath:              cssPath,
		jsEngine:             otto.New(),
		transformationScript: transformationScript,
	}
}

type UrlScraper struct {
	AbstractDataSource
	url                  string
	cssPath              string
	jsEngine             *otto.Otto
	transformationScript string
}

func (this *UrlScraper) Retrieve(sampleChan chan *Sample) {
	t := time.Now()
	doc, err := goquery.NewDocument(this.url)
	if err != nil {
		sampleChan <- NewSample("", t, this.dataSourceId, err)
		return
	}

	value := doc.Find(this.cssPath).Text()
	if len(value) == 0 {
		sampleChan <- NewSample("", t, this.dataSourceId, errors.New("The specified CSS path is invalid or doesn't match any DOM nodes."))
		return
	}

	if len(this.transformationScript) > 0 {
		// TODO: perform some JS sanitation to prevent injection of harmful JS code
		value = strings.Replace(value, "'", "\\'", -1)
		value = strings.Replace(value, "\n", "", -1)
		value = strings.Replace(value, "\r", "", -1)

		_, err = this.jsEngine.Run("var value = '" + value + "';")
		if err != nil {
			sampleChan <- NewSample("", t, this.dataSourceId, err)
			return
		}

		jsValue, err := this.jsEngine.Run("value = " + this.transformationScript + ";")
		if err != nil {
			sampleChan <- NewSample("", t, this.dataSourceId, err)
			return
		}

		value = jsValue.String()
		if len(value) == 0 {
			sampleChan <- NewSample("", t, this.dataSourceId, errors.New("Couldn't perform the provided JS transformation."))
			return
		}
	}

	sampleChan <- NewSample(value, t, this.dataSourceId, nil)
}

func (this *UrlScraper) Type() string {
	return DsUrlScraper
}

func (this *UrlScraper) GobEncode() ([]byte, error) {
	// TODO: It might make sense to include a version number in the encoding due to future changes.

	fmt.Println("   [UrlScraper]   GobEncode()")

	buff := new(bytes.Buffer)
	encoder := gob.NewEncoder(buff)

	err := encoder.Encode(this.AbstractDataSource)
	if err != nil {
		return nil, err
	}

	err = encoder.Encode(this.url)
	if err != nil {
		return nil, err
	}

	err = encoder.Encode(this.cssPath)
	if err != nil {
		return nil, err
	}

	err = encoder.Encode(this.transformationScript)
	if err != nil {
		return nil, err
	}

	return buff.Bytes(), nil
}

func (this *UrlScraper) GobDecode(urlScraperBytes []byte) error {
	// TODO: It might make sense to include a version number in the encoding due to future changes.
	fmt.Println("   [UrlScraper]   GobDecode()")

	buff := bytes.NewBuffer(urlScraperBytes)
	decoder := gob.NewDecoder(buff)

	err := decoder.Decode(&this.AbstractDataSource)
	if err != nil {
		return err
	}

	err = decoder.Decode(&this.url)
	if err != nil {
		return err
	}

	err = decoder.Decode(&this.cssPath)
	if err != nil {
		return err
	}

	err = decoder.Decode(&this.transformationScript)
	if err != nil {
		return err
	}

	return nil
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ██████╗ ███████╗██████╗  ██████╗ ██████╗ ████████╗██╗███╗   ██╗ ██████╗  ***** */
/* ***** ██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗╚══██╔══╝██║████╗  ██║██╔════╝  ***** */
/* ***** ██████╔╝█████╗  ██████╔╝██║   ██║██████╔╝   ██║   ██║██╔██╗ ██║██║  ███╗ ***** */
/* ***** ██╔══██╗██╔══╝  ██╔═══╝ ██║   ██║██╔══██╗   ██║   ██║██║╚██╗██║██║   ██║ ***** */
/* ***** ██║  ██║███████╗██║     ╚██████╔╝██║  ██║   ██║   ██║██║ ╚████║╚██████╔╝ ***** */
/* ***** ╚═╝  ╚═╝╚══════╝╚═╝      ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝╚═╝  ╚═══╝ ╚═════╝  ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag ***** ***** ***** */

// TODO: Refactor this section to a separate package!
// TODO: Add test cases

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type Reporter interface {
	OnSample(sample *Sample)
	Prepare() error
	ShutDown() error
}

type ReportingEngine interface {
	Register(reporters ...Reporter)
	Distribute(sample *Sample)
	ShutDown() error
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewSocketIOReporter(socketIOApi SocketIOApi) SocketIOReporter {
	return SocketIOReporter{socketIOApi: socketIOApi}
}

type SocketIOReporter struct {
	socketIOApi SocketIOApi
}

func (r SocketIOReporter) OnSample(sample *Sample) {
	r.socketIOApi.Broadcast(sample)
}

func (r SocketIOReporter) Prepare() error {
	return nil
}

func (r SocketIOReporter) ShutDown() error {
	return nil
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewConsoleReporter(prefix string) ConsoleReporter {
	return ConsoleReporter{prefix: prefix}
}

type ConsoleReporter struct {
	prefix string
}

func (r ConsoleReporter) OnSample(sample *Sample) {
	fmt.Printf("%s%s\n", r.prefix, sample)
}

func (r ConsoleReporter) Prepare() error {
	return nil
}

func (r ConsoleReporter) ShutDown() error {
	return nil
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewPersistentDataStoreReporter(dataStore DataStore, flushInterval time.Duration) *PersistentDataStoreReporter {
	r := &PersistentDataStoreReporter{
		dataStore:                     dataStore,
		flushTicker:                   time.NewTicker(flushInterval),
		sampleChan:                    make(chan *Sample),
		sampleRequestChan:             make(chan SampleRetrievalRequest),
		quantitativeSampleRequestChan: make(chan QuantitativeSampleRetrievalRequest),
	}

	go func() {
		for {
			select {
			case <-r.flushTicker.C:
				samplesToFlush := r.buffer[0:len(r.buffer)]
				err := r.dataStore.PersistSamples(samplesToFlush)
				if err != nil {
					fmt.Println("[PersistentDataStoreReporter] Couldn't persist samples due to:", err)
				}

				// clear buffer
				// Attention! This might produce a memory leak...
				// see: http://stackoverflow.com/questions/16971741/how-do-you-clear-a-slice-in-go
				r.buffer = r.buffer[:0]

			case sample := <-r.sampleChan:
				// it might be better to impl. a custom append() function for performance reasons
				// but in the first version the built-in one is sufficient
				r.buffer = append(r.buffer, sample)

			case sampleRetrievalRequest := <-r.sampleRequestChan:
				var eligibleSamples []*Sample

				for _, sample := range r.buffer {
					doesDataSourceIdMatch := sample.DataSourceId == sampleRetrievalRequest.DataSourceId
					doesFromTimeMatch := sample.Timestamp.Equal(sampleRetrievalRequest.From) || sample.Timestamp.After(sampleRetrievalRequest.From)
					doesToTimeMatch := sample.Timestamp.Equal(sampleRetrievalRequest.To) || sample.Timestamp.Before(sampleRetrievalRequest.To)

					if doesDataSourceIdMatch && doesFromTimeMatch && doesToTimeMatch {
						eligibleSamples = append(eligibleSamples, sample)
					}
				}

				sampleRetrievalRequest.ResponseChan <- eligibleSamples

			case quantitativeSampleRetrievalRequest := <-r.quantitativeSampleRequestChan:
				var eligibleSamples []*Sample

				for _, sample := range r.buffer {
					if len(eligibleSamples) < quantitativeSampleRetrievalRequest.Quantity && sample.DataSourceId == quantitativeSampleRetrievalRequest.DataSourceId {
						eligibleSamples = append(eligibleSamples, sample)
					}
				}

				quantitativeSampleRetrievalRequest.ResponseChan <- eligibleSamples
			}
		}
	}()

	return r
}

type PersistentDataStoreReporter struct {
	dataStore                     DataStore
	buffer                        []*Sample
	flushTicker                   *time.Ticker
	sampleChan                    chan *Sample
	sampleRequestChan             chan SampleRetrievalRequest
	quantitativeSampleRequestChan chan QuantitativeSampleRetrievalRequest
}

func (r *PersistentDataStoreReporter) OnSample(sample *Sample) {
	r.sampleChan <- sample
}

func (r *PersistentDataStoreReporter) GetSamples(dataSourceId string, from time.Time, to time.Time) []*Sample {
	responseChan := make(chan []*Sample)
	sampleRetrievalRequest := SampleRetrievalRequest{DataSourceId: dataSourceId, From: from, To: to, ResponseChan: responseChan}
	r.sampleRequestChan <- sampleRetrievalRequest
	return <-responseChan
}

func (r *PersistentDataStoreReporter) GetLatestSamples(dataSourceId string, num int) []*Sample {
	responseChan := make(chan []*Sample)
	sampleRetrievalRequest := QuantitativeSampleRetrievalRequest{DataSourceId: dataSourceId, Quantity: num, ResponseChan: responseChan}
	r.quantitativeSampleRequestChan <- sampleRetrievalRequest
	return <-responseChan
}

func (r *PersistentDataStoreReporter) Prepare() error {
	return r.dataStore.Prepare()
}

func (r *PersistentDataStoreReporter) ShutDown() error {
	// TODO: stop ticker, flush remaining samples, and afterwards shutdown the data store
	return r.dataStore.ShutDown()
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type SampleRetrievalRequest struct {
	DataSourceId string
	From         time.Time
	To           time.Time
	ResponseChan chan []*Sample
}

type QuantitativeSampleRetrievalRequest struct {
	DataSourceId string
	Quantity     int
	ResponseChan chan []*Sample
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewKasperbrettReportingEngine() *KasperbrettReportingEngine {
	re := &KasperbrettReportingEngine{
		reporterRegistrationChan: make(chan Reporter),
		sampleChan:               make(chan *Sample),
		shutDownChan:             make(chan chan error),
	}

	go func() {
		for {
			select {
			case reporter := <-re.reporterRegistrationChan:
				re.reporters = append(re.reporters, reporter) // it is valid to append data to nil slices
				reporter.Prepare()                            // TODO: handle error that might happen during preparation
			case sample := <-re.sampleChan:
				for _, reporter := range re.reporters {
					go reporter.OnSample(sample)
				}
			case responseChan := <-re.shutDownChan:
				var overallErr error = nil
				for _, reporter := range re.reporters {
					err := reporter.ShutDown()
					if err != nil && overallErr == nil {
						overallErr = err
					}
				}
				responseChan <- overallErr
			}
		}
	}()

	return re
}

type KasperbrettReportingEngine struct {
	reporters                []Reporter
	reporterRegistrationChan chan Reporter
	sampleChan               chan *Sample
	shutDownChan             chan chan error
}

func (re *KasperbrettReportingEngine) Register(reporters ...Reporter) {
	for _, reporter := range reporters {
		re.reporterRegistrationChan <- reporter
	}
}

func (re *KasperbrettReportingEngine) Distribute(sample *Sample) {
	re.sampleChan <- sample
}

func (re *KasperbrettReportingEngine) ShutDown() error {
	responseChan := make(chan error)
	re.shutDownChan <- responseChan
	return <-responseChan
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ███████╗ ██████╗██╗  ██╗███████╗██████╗ ██╗   ██╗██╗     ██╗███╗   ██╗ ██████╗  ***** */
/* ***** ██╔════╝██╔════╝██║  ██║██╔════╝██╔══██╗██║   ██║██║     ██║████╗  ██║██╔════╝  ***** */
/* ***** ███████╗██║     ███████║█████╗  ██║  ██║██║   ██║██║     ██║██╔██╗ ██║██║  ███╗ ***** */
/* ***** ╚════██║██║     ██╔══██║██╔══╝  ██║  ██║██║   ██║██║     ██║██║╚██╗██║██║   ██║ ***** */
/* ***** ███████║╚██████╗██║  ██║███████╗██████╔╝╚██████╔╝███████╗██║██║ ╚████║╚██████╔╝ ***** */
/* ***** ╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═════╝  ╚═════╝ ╚══════╝╚═╝╚═╝  ╚═══╝ ╚═════╝  ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag ***** ***** ****** ***** */

// TODO: Refactor this section to a separate package!
// TODO: Add test cases

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type SchedulerJob struct {
	ticker *time.Ticker
	t      tomb.Tomb
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type Scheduler interface {
	Schedule(dataSourceId string, interval time.Duration, jobFn func(reportingEngine ReportingEngine)) (chan string, chan error)
	GetAll() (chan map[string]*SchedulerJob, chan error)
	Cancel(dataSourceId string) (chan bool, chan error)
	ShutDown() (chan bool, chan error)
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type SchedulerRequest interface {
	Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine)
	ErrorChan() chan error
	IsShutDownRoutine() bool
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewAbstractSchedulerRequest() AbstractSchedulerRequest {
	return AbstractSchedulerRequest{errorChan: make(chan error, 1)}
}

type AbstractSchedulerRequest struct {
	errorChan chan error
}

func (req AbstractSchedulerRequest) ErrorChan() chan error {
	return req.errorChan
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type AddJobRequest struct {
	AbstractSchedulerRequest
	responseChan chan string
	interval     time.Duration
	jobFn        func(reportingEngine ReportingEngine)
	dataSourceId string
}

func (req AddJobRequest) Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine) {
	job := &SchedulerJob{ticker: time.NewTicker(req.interval)}
	registry[req.dataSourceId] = job

	job.t.Go(func() error {
		for {
			select {
			case <-job.ticker.C:
				req.jobFn(reportingEngine)
			case <-job.t.Dying():
				return nil
			}
		}
	})

	req.responseChan <- req.dataSourceId
}

func (req AddJobRequest) IsShutDownRoutine() bool {
	return false
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type GetAllJobsRequest struct {
	AbstractSchedulerRequest
	responseChan chan map[string]*SchedulerJob
}

func (req GetAllJobsRequest) Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine) {
	registrySnapshot := make(map[string]*SchedulerJob, len(registry))

	for jobId, job := range registry {
		jobCopy := *job
		registrySnapshot[jobId] = &jobCopy
	}

	req.responseChan <- registrySnapshot
}

func (req GetAllJobsRequest) IsShutDownRoutine() bool {
	return false
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type RemoveJobRequest struct {
	AbstractSchedulerRequest
	responseChan chan bool
	jobId        string
}

func (req RemoveJobRequest) Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine) {
	job, ok := registry[req.jobId]
	var err error = nil
	if !ok {
		err = errors.New("Job not available: " + req.jobId)
	} else {
		job.ticker.Stop()
		delete(registry, req.jobId)
		job.t.Kill(nil)
		err = job.t.Wait()
	}
	req.errorChan <- err
	req.responseChan <- true
}

func (req RemoveJobRequest) IsShutDownRoutine() bool {
	return false
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type RemoveAllJobsRequest struct {
	AbstractSchedulerRequest
	responseChan chan bool
}

func (req RemoveAllJobsRequest) Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine) {
	var overallErr error = nil
	for jobId, job := range registry {
		// TODO: remove redundant code
		job.ticker.Stop()
		delete(registry, jobId)
		job.t.Kill(nil)
		err := job.t.Wait()

		if err != nil && overallErr == nil {
			overallErr = err
		}
	}
	req.errorChan <- overallErr
	req.responseChan <- true
}

func (req RemoveAllJobsRequest) IsShutDownRoutine() bool {
	return true
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewKasperbrettScheduler(reportingEngine ReportingEngine) *KasperbrettScheduler {
	ks := &KasperbrettScheduler{
		reportingEngine: reportingEngine,
		requestChan:     make(chan SchedulerRequest),
		registry:        make(map[string]*SchedulerJob),
		isShutDown:      false,
	}

	go func() {
		for {
			req := <-ks.requestChan

			if ks.isShutDown {
				errorChan := req.ErrorChan()
				errorChan <- errors.New("The KasperbrettScheduler has already been shut down.")
			} else {
				req.Run(ks.registry, ks.reportingEngine)
				ks.isShutDown = req.IsShutDownRoutine()
			}
		}
	}()

	return ks
}

type KasperbrettScheduler struct {
	reportingEngine ReportingEngine
	requestChan     chan SchedulerRequest
	registry        map[string]*SchedulerJob
	isShutDown      bool
}

func (ks *KasperbrettScheduler) Schedule(dataSourceId string, interval time.Duration, jobFn func(reportingEngine ReportingEngine)) (chan string, chan error) {
	// we need a buffered chan in case the caller is not interested in the response value (jobId)
	// an unbuffered chan would block our request processing goroutine forever
	responseChan := make(chan string, 1)
	abstractSchedulerRequest := NewAbstractSchedulerRequest()

	req := AddJobRequest{
		AbstractSchedulerRequest: abstractSchedulerRequest,
		responseChan:             responseChan,
		interval:                 interval,
		jobFn:                    jobFn,
		dataSourceId:             dataSourceId,
	}
	ks.requestChan <- req

	return responseChan, abstractSchedulerRequest.ErrorChan()
}

func (ks *KasperbrettScheduler) GetAll() (chan map[string]*SchedulerJob, chan error) {
	// reasoning for buffered chan: see explanation in Schedule() impl.
	responseChan := make(chan map[string]*SchedulerJob, 1)
	abstractSchedulerRequest := NewAbstractSchedulerRequest()

	req := GetAllJobsRequest{
		AbstractSchedulerRequest: abstractSchedulerRequest,
		responseChan:             responseChan,
	}
	ks.requestChan <- req

	return responseChan, abstractSchedulerRequest.ErrorChan()
}

func (ks *KasperbrettScheduler) Cancel(jobId string) (chan bool, chan error) {
	// reasoning for buffered chan: see explanation in Schedule() impl.
	responseChan := make(chan bool, 1)
	abstractSchedulerRequest := NewAbstractSchedulerRequest()

	req := RemoveJobRequest{
		AbstractSchedulerRequest: abstractSchedulerRequest,
		responseChan:             responseChan,
		jobId:                    jobId,
	}
	ks.requestChan <- req

	return responseChan, abstractSchedulerRequest.ErrorChan()
}

func (ks *KasperbrettScheduler) ShutDown() (chan bool, chan error) {
	// reasoning for buffered chan: see explanation in Schedule() impl.
	responseChan := make(chan bool, 1)
	abstractSchedulerRequest := NewAbstractSchedulerRequest()

	req := RemoveAllJobsRequest{
		AbstractSchedulerRequest: abstractSchedulerRequest,
		responseChan:             responseChan,
	}
	ks.requestChan <- req

	return responseChan, abstractSchedulerRequest.ErrorChan()
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
